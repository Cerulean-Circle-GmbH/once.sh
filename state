#!/usr/bin/env bash
#clear
#export PS4='\e[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \e[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

### new.method

private.states.init() # # initialises the stateMachine folder in $CONFIG_PATH 
{
  check dir $CONFIG_PATH/stateMachines not exists \
    call mkdir -p $CONFIG_PATH/stateMachines 
}

state.of() # <machine> <?method> # returns the state of the <machine>
{
  local machine=$1
  local stateID=${machine}_STATE_ID
  shift

  source $CONFIG_PATH/stateMachines/${machine}.states.env
  local state=${!stateID}
  local stateName="${machine}_STATES[${state}]"

  debug.log "machine ${YELLOW}$machine ${CYAN}state is: ${WHITE}${!stateName}"
  export STATE_MACHINE_CURRENT=$machine

  if [ -n "$1" ]; then 
    local call=$1
    shift
    state.$call - "$@"
    shift
  else
    echo ${state}
  fi
  RETURN=$1
}


state.name() # <machine> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $machine name
    return 0
  fi
  echo ${!stateName}
}

state.id() # <machine> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $machine id
    return 0
  fi
  echo ${state}
}

state.parameter.completion.machine() {
  state.list.machines $1
}

state.parameter.completion.nameFilter() {
  state.list.machines $1
}

state.list.machines() # <?nameFilter> # lists all available stateMachines
{
  cd $CONFIG_PATH/stateMachines
  c2 files.completion $1 | line replace ".states.env"

  if [ -n "$1" ]; then shift; fi
  RETURN=$1
}

state.parameter.completion.method() {
  echo "list"
  echo "id"
  echo "name"
  echo "add"
  echo "stage"
  echo "start"
}

state.find() # <machine> <state> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $machine find "$@"
    shift
    RETURN=$1
    return 0
  fi

  
  local stateName=$1
  if [ -n "$1" ]; then shift; fi  

  if this.isNumber $stateName;then
    local stateName="${machine}_STATES[${state}]"
    important
    echo ${!stateName}
  else
    echo "$stateName"
  fi

  echo find to ${stateName}
  shift
  RETURN=$1
}

state.stage() # <machine> <stateName> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $machine add "$@"
    shift
    RETURN=$1
    return 0
  fi

  
  local stateName=$1
  if [ -n "$1" ]; then shift; fi  

  echo stage to ${stateName}
  shift
  RETURN=$1
}

state.add() # <machine> <stateName> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $machine add "$@"
    shift
    RETURN=$1
    return 0
  fi

  
  local stateName=$1
  if [ -n "$1" ]; then shift; fi  

  echo add ${stateName}
  shift
  RETURN=$1
}

state.list() # <machine> <stateName> #
{
  local aMachine=$1
  if [ -n "$1" ]; then shift; fi
  if ! [ "$aMachine" = "-" ]; then 
    state.of $aMachine list "$@"
    shift
    RETURN=$1
    return 0
  fi

  
  local stateFilter=$1
  if [ -n "$1" ]; then shift; fi  

  debug.log "machine=${machine}    stateFilter=${stateFilter}   1=$1"



  important.log "${machine}_STATES selected.
  current state: 
  
  [${state}]=${!stateName}
  "
  echo " "

  local stateList="${machine}_STATES[@]"

  let i=0
  let count=0
  let countInternal=0
  for index in "${!stateList}"; do
    local currentName="${machine}_STATES[$i]"
    debug.log looping ${currentName}  at $index loop $i
    if [ "$state" -lt "$i" ] || [ "$stateFilter" = "all" ]; then
      if this.isNumber ${!currentName}; then
        debug.log "skipping ${!currentName}"
        local next=${!currentName}
        i=$next-1
      else 
        let count++
        local colorMod=""
        if [ "$i" -eq "${state}" ]; then
          colorMod=${CYAN}
        fi
        console.log "${colorMod}[$i]\t= ${!currentName}"
      fi
    fi
    let i++
    let countInternal++
  done

  echo
  let transitionStates=$countInternal-$count
  important.log "${machine}_STATES has $count states (and $transitionStates transition states)
  
  "

  shift
  RETURN=$1
}

state.machine.create() # <machine> # creates a stateMachine
{
  local machine=$1
  check file $CONFIG_PATH/stateMachines/${machine}.states.env not exists \
    call state machine.init $machine
}

state.machine.init() {
  local machine=$1
  declare -xag ${machine}_STATES='(\
    [0]="not.installed" \
    [1]="initialized" \
    [2]="setup" \
    [3]="all.states.added" \
    [4]="started" \
    [5]=11 \
    [6]=to.be.deleted \
    [11]="next.custom.state" \
    [12]=99 \
    [99]="finished" \
    [100]=6
    )' 
  
  declare -x ${machine}_STATE_ID=1 >>$CONFIG_PATH/stateMachines/${machine}.states.env
  {
    declare -a | line find ${machine}_STATES | line replace ' \[' ' \\-SPLIT-[' | line split '-SPLIT-' | line unquote
    local name=${machine}_STATE_ID
    echo
    echo ${name}=${!name}
  }>$CONFIG_PATH/stateMachines/${machine}.states.env
  
}

state.parameter.completion.state() {
  important.log "Par: $@"
  local stateFilter=$1
  if [ -n "$1" ]; then shift; fi  
  local machine="$STATE_MACHINE_CURRENT"

  debug.log "machine=${machine}    stateFilter=${stateFilter}   1=$1"

  local stateList="${machine}_STATES[@]"

  let i=0
  let count=0
  let countInternal=0
  for index in "${!stateList}"; do
    local currentName="${machine}_STATES[$i]"
    debug.log looping ${currentName}  at $index loop $i
    if [ "$state" -lt "$i" ] || [ "$stateFilter" = "all" ]; then
      if this.isNumber ${!currentName}; then
        debug.log "skipping ${!currentName}"
        local next=${!currentName}
        i=$next-1
      else 
        let count++
        local colorMod=""
        if [ "$i" -eq "${state}" ]; then
          colorMod=${CYAN}
        fi
        echo "${!currentName}"
      fi
    fi
    let i++
    let countInternal++
  done

  echo
  let transitionStates=$countInternal-$count
  important.log "${machine}_STATES has $count states (and $transitionStates transition states)
  
  "

  shift
  RETURN=$1
}

state.machine.edit() # <machine> # creates a stateMachine
{
  local machine=$1
  oo cmd vim
  vim $CONFIG_PATH/stateMachines/${machine}.states.env
}

state.machine.delete() # <machine> # creates a stateMachine
{
  local machine=$1
  oo cmd vim
  rm $CONFIG_PATH/stateMachines/${machine}.states.env
}



state.usage()
{
  local this=${0##*/}
  echo "You started" 
  echo "$0

  state allows you to create and handle multiple state machines

  Usage:
  $this: command   Parameter and Description"
  this.help
  echo "
  
  Examples
    $this list
    $this init
    ----------
  "
}

state.start()
{
  #echo "sourcing init"
  source this
  private.states.init

  # if [ -z "$1" ]; then
  #   status.discover "$@"
  #   return 0
  # fi

  this.start "$@"
}

state.start "$@"

