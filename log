#!/usr/bin/env bash

# echo "entering: ${BASH_SOURCE[0]}"
# echo "remove all echos to preseve output"
# echo ""

# export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
# set -x

log.init()
{
  if [ -n "$1" ]; then
    export LOG_LEVEL="$1"
    important.log "log level changed to $LOG_LEVEL"
  else
    export LOG_LEVEL=3
  fi

  important.log "log initialized on level $LOG_LEVEL"
}

if ! [ "$(type -t info.log)" = "function" ]; then
  source this; 
fi  



console.log()
{
  if [ "$LOG_LEVEL" -gt "2" ]; then
    echo -e "${ESC}0m$*" 
  fi
}

silent.log() {
    if [ "$LOG_LEVEL" -gt "2" ]; then
        echo -e "${ESC}90m  $*\033[0m" 
    fi
}

success.log() {
    if [ "$LOG_LEVEL" -gt "2" ]; then
        echo -e "${BOLD};32mSUCCESS> $*\033[0m" 
    fi
}

test.success.log() {
    if [ "$LOG_LEVEL" -gt "0" ]; then
        echo -e "${BOLD};32mSUCCESS> $*\033[0m" 
    fi
}

error.details.log() {
    if [ "$LOG_LEVEL" -gt "0" ]; then
      echo -e "${ESC}0m$*"
    fi
}

warn.log()
{
    if [ "$LOG_LEVEL" -gt "1" ]; then
        echo -e "${BOLD};33m> WARNING $*\033[0m" | tee -a $CONFIG_PATH/error.txt >>$CONFIG_PATH/result.txt                               ## yellow
    fi
    {
      shift
      RETURN=$1
    } 2>/dev/null
}

important.log()
{
    if [ "$LOG_LEVEL" -gt "1" ]; then
        echo -e "${BOLD};96mIMPORTANT> $*\033[0m"                                    ## cyan
    fi
    {
      shift
      RETURN=$1
    } 2>/dev/null
}

problem.log() {
    if [ "$LOG_LEVEL" -gt "1" ]; then
        echo -e "${BOLD};31mPROBLEM BREAKPOINT> $*\033[0m" 
        export STEP_DEBUG=ON
    fi  
}



debug.log() {
    if [ "$LOG_LEVEL" -gt "4" ]; then  
        echo -e "${BOLD};36m- $*\033[0m"
    fi
}

stop.log() {
    if [ "$LOG_LEVEL" -gt "3" ]; then
        echo -e "${BOLD};32mBREAKPOINT> $*\033[0m" 
        export STEP_DEBUG=ON
    fi  
}

error.log() {
    err.log "$@"
}
err.log() {

    if [ "$LOG_LEVEL" -gt 0 ]; then
       echo -e "${BOLD};31mERROR> $*\033[0m" | tee -a $CONFIG_PATH/error.txt $CONFIG_PATH/result.txt     
    fi

    if [ "$LOG_LEVEL" -gt "4" ]; then   
        export STEP_DEBUG=ON
    fi   
}

capture.log() {
  clear.resultFiles
  important.log "capturing logs of:
   $*"
   #### write to console AND result.text AND wite errors to errot.txt AND result.txt
   "$@" > >(tee -a $CONFIG_PATH/result.txt) 2> >(tee -a $CONFIG_PATH/result.txt $CONFIG_PATH/error.txt >&2)
}

capture.log.silent() {
  clear.resultFiles
  important.log "capturing logs of:
   $*
   
   use ${WHITE}log inspect${CYAN} in another shell to see whats going on.

   waiting for results...
   "
   #### write to console AND result.text AND wite errors to errot.txt AND result.txt
   "$@" >$CONFIG_PATH/result.txt 2> >(tee -a $CONFIG_PATH/result.txt $CONFIG_PATH/error.txt >&2)
   important.log "
   results ready in: $CONFIG_PATH/result.txt"
}

log.capture.result() {
  capture.log "$@"
}

log.capture.result.silent() {
  capture.log.silent "$@"
}



log.inspect() {
  tail -f $CONFIG_PATH/result.txt
}

log.inspect.errors() {
  tail -f $CONFIG_PATH/error.txt
}

clear.resultFiles() {
  cd $CONFIG_PATH
  if [ -f result.txt ]; then
    rm result.txt
  else
    silet.log "result.txt already clean"
  fi

  if [ -f error.txt ]; then
    rm error.txt
  else
    silet.log "error.txt already clean"
  fi
  success.log "result log files cleared"
  cd -
}

# log.noop() 
# {
#   return 0
# }

log.level()
{
  if [ -n "$1" ]; then
    local level=$1
    if [ "$level" = "reset" ]; then
      local current=$LOG_LEVEL
      export LOG_LEVEL=$LOG_LEVEL_RESET
      export LOG_LEVEL_RESET=$current
    else
      export LOG_LEVEL_RESET=$LOG_LEVEL
      export LOG_LEVEL="$1"
      important.log "log level changed to $LOG_LEVEL"
      check.debug.level
    fi

    if (this.isSourced); then
      info.log "log level sourced"
    else
        info.log "log level started"
        config save log LOG
        exit 0
        #config add log
    fi

    shift  
    export RETURN=$1
  else
    this=${0##*/}
    RESULT="export LOG_LEVEL=$LOG_LEVEL" 
    RETURN="$1" 
    echo "$RESULT"
    if [ "$this" = "log" ]; then
      debug.log "$this was started"
      exit 0
    else
      debug.log "$this was sourced"
    fi
  fi

  # LOG_LEVEL=6
  # check.debug.level


}

log.init.colors() 
{
  ESC="\033["
  BOLD="${ESC}1"
  RED="${BOLD};31m"
  GREEN="${BOLD};32m"
  BLUE="${ESC}0m"
  CYAN="${BOLD};96m"
  GRAY="${ESC}90m"
  YELLOW="${BOLD};33m"
  WHITE="${BOLD};37m"

  NORMAL="${ESC}0m"
  COLOR_NONE="${ESC}0m"

  COLOR_RED=${RED}
  COLOR_GREEN=${GREEN}
  COLOR_BLUE=${BLUE}
  COLOR_CYAN=${CYAN}
  COLOR_GRAY=${GRAY}
  COLOR_YELLOW=${YELLOW}
  COLOR_WHITE=${WHITE}
}

log.usage()
{
  local this=${0##*/}
  echo "You started

  Usage:
  $this: command <parameter>
    important.log
    success.log
    warn.log
    error.log
    info.log
    debug.log
    stop.log
    silent.log


  Examples
    $this level <0...7>
  "
}



log.start()
{
  #echo "log startet"
  log.init.colors
  if [ -z "$LOG_LEVEL" ]; then
    log.init $1
  else
    local command=$1
    # if [ -z "$command" ]; then
    #  command="level"
    # fi
    this=${0##*/}
    if [ "$this" = "log" ]; then
      debug.log "$this was started"
    else
      return 0
    fi


    if [ -n "$command" ]; then

      if (this.functionExists log.$command) ; then
        shift
        log.$command "$@"
      # else
      #   if ! [ "$command" = "silent" ]; then
      #     console.log "$@"
      #   fi
      fi
    else
      log.usage
      exit 0
    fi
    #if [ "$(type -t this.init)" = "function" ]; then
      #result 0 "export LOG_LEVEL=$LOG_LEVEL" "$1" >/dev/null
    #else
      RETURN_VALUE=0
      RESULT="export LOG_LEVEL=$LOG_LEVEL"
      RETURN="$1"
    #fi
    return $RETURN_VALUE
  fi

  check.debug.level
  create.result 0 "export LOG_LEVEL=$LOG_LEVEL" "$1" >/dev/null
  return $(result)
}

log.start "$@"




# console.log "
# console.log: still in ${BASH_SOURCE[0]##*/}
# "
