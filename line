#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

### new.method

line.split() { # <?seperator:" ">    splits the line (for env variables use split.env  because of quoting)
  local seperator="$1"
  if [ -z "$seperator" ]; then
    cat - | sed -e $'s/ /\\\n/g'
    return $?
  fi
  #cat - | tr "$seperator" "\n"
  cat - | sed -e 's/'$seperator'/'$'\\\n''/g'
}

line.split.test() { # <?seperator:" ">
  local seperator="$1"
  if [ -z "$seperator" ]; then
    cat - | sed -e $'s/ /\\\n/g'
    return $?
  fi
  #cat - | tr "$seperator" "\n"
  cat - | sed -e 's/'$seperator'/'$'\\\n''/g'
}

line.replace() { # <?word:" "> <?by:"">    replace <word> with <by>. for new line use $'\\\n' 
  local word="$1"
  if [ -n "$1" ]; then
    word="$1"
    shift
  else
    word=''
  fi

  local by="$1"
  if [ -n "$1" ]; then
    by="$1"
    shift
  else
    by=''
  fi

  #cat - | tr "$seperator" "\n"
  cat - | sed "s/$word/$by/g"
}


line.split.quoted() { # <?word:"="> <?by:"">    replace word by by. for new line use $'\\\n' 
  local word="$1"
  if [ -n "$1" ]; then
    word="$1"
    shift
  else
    word='='
  fi

  local by="$1"
  if [ -n "$1" ]; then
    by="$1"
    shift
  else
    by="'"$'\\\n'"'"
  fi

  #cat - | tr "$seperator" "\n"
  cat - | sed "s/$word/$by/g"
}

line.split.env() {
  local word="$1"
  if [ -n "$1" ]; then
    word="$1"
    shift
  else
    word='='
  fi
  cat - | line.quote | line.split.quoted "$word"
}

line.format.env() {       # <?format:"${RED}%-40s${YELLOW}=${GREEN} %-20s\n">
    local format="$1"
  if [ -n "$1" ]; then
    format="$1"
    shift
  else
    format="${RED}%-40s${YELLOW}=${GREEN} %-20s\n"
  fi
  cat - | line split.env | line format "$format"
}

line.keys() { # <?seperator:" ">
  local seperator="$1"
  if [ -z "$seperator" ]; then
    seperator=' '
  fi
  cat - | cut -d "$seperator" -f1
}

line.values() { # <?seperator:" ">
  local seperator="$1"
  if [ -z "$seperator" ]; then
    seperator=' '
  fi
  cat - | cut -d "$seperator" -f2
}

line.select() {               # <?lineNumber>
  cat - | sed -n "$1p"
}

line.remove() {               # <?lineNumber>
  cat - | sed -n "$1d"
}

line.count() {
  cat - | grep -c "$1$"
}

line.join() {                 # <?charakter=".">
  local char="$1"
  if [ -n "$1" ]; then
    shift
  else
    char="."
  fi

  cat - | xargs | sed -e "s/ /$char/g"
}

line.key() { # <?charakter=" ">
  line.split "$1" | line select 1
}

line.value() { # <?charakter=" ">
  line.split "$1" | line select 2
}

line.trim() {
  #all
  cat - | xargs 
}

line.trim.leading() {
  #leading
  cat - | sed -e 's/^[[:space:]]*//'
}

line.trim.trailing() {
  #trailing
  cat - | sed -e 's/[[:space:]]*$//'
}

line.dots() {
  line.space2 '.'
}

line.space2() { # <?charakter=" ">
  local replace="$1"
  if [ -z "$replace" ]; then
    replace='.'
  fi
  cat - | sed -e "s/[[:space:]]/$replace/g"
}

line.find() { # <from> <to:"[empty line]">
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    error.log "no parameter 'from' provided"
  fi

  local to="$1"
  if [ -n "$1" ]; then
    to="$1"
    shift
  else
    to="$"
  fi

  if this.isNumber "$to"; then
    cat - | grep -A "$to" "$from"
  else
    cat - | awk "/$from/,/$to/" 
  fi
}

# line.each() {
#   cat - | xargs -L 1 | "$@"
# }

line.table() { # <?seperator:";"> <?heading:" ">  prints a table (standad for csv)
  local seperator="$1"
  if [ -n "$1" ]; then
    seperator="$1"
    shift
  else
    seperator=";"
  fi

  # local heading="$1"
  # if [ -n "$1" ]; then
  #   heading="$1"
  #   shift
  #   #https://github.com/jorinvo/prepend
  #   cat - | prepend "$heading" | column -t -s "$seperator"
  #   return 0
  # fi

  cat - | column -t -s "$seperator"

}

line.format() {
  local format="$1"
  if [ -n "$1" ]; then
    format="$1"
    shift
  else
    format="%s "
  fi
  cat - | xargs  printf "$format"
}

line.quote() {
  cat - | tr '\n' '\0' | xargs -0 -n1 printf "'%s'\n"

  #cat - | line.format "\'%s\' "
}

line.args() {
  #printf "\'%s\'\n" "$( cat - )"

  cat - | line.format "\'%s\' "
}



line.declare() {
  env | line split = | line join ' ' | xargs  printf 'declare -l %s=%s\n'
}



line.usage()
{
  local this=${0##*/}
  echo "You started" 
  echo "$0

  Usage:
  $this: command   description and Parameter

      usage     prints this dialog while it will print the status when there are no parameters          
      v         print version information
      init      initializes ...nothing yet
      ----      --------------------------"
  this.help
  echo "
  
  Examples
    $this v
    $this init
    echo cool.and.the.gang is mega | line split ' ' | line split . | line select 6
                                                                     line join '#'
    echo key=value | line key =
    echo \" key value\" | line trim | line key 
    echo \$PATH | line split : | sort  | uniq | line join :
    env | line find KEYC | line format.env | line value =
  "
}

line.start()
{
  #echo "sourcing init"
  source this
  REGEX_EMPTY_LINE="^$"
  REGEX_LINE_END="$"
  REGEX_BRACKETS="\(\)"
  REGEX_NEW_LINE=$'\\\n'
  REGEX_TEST='Test'


  # if [ -z "$1" ]; then
  #   status.discover "$@"
  #   return 0
  # fi

  this.start "$@"
}

line.start "$@"

