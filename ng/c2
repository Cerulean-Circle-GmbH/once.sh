#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

### new.method


c2.get.functions()  # <script> <functionNameFilter> # lista all functions in a script with description
# functions are identified by someFunctionName( ) but mainly by the brackets ()
# they are parsed till the next curley bracket
# so that this detailed description is part of the grep
{
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  cat "$from" \
  | line.find "[^ ]*$1[^ ]*\(\) " "{" \
  | line.filter "^{" \

  # | line.replace "$name\." \
  # | grep "$1"

  # | line.filter "^#" \
  # | sort \
}

c2.format.functions() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$@" \
  | line.replace "$" "${NO_COLOR}" \
  | line.replace "^#" "${GREEN}#" \
  | line.replace "$name\." "${CYAN}${name}${NO_COLOR}\." \
  | line.replace "\([^ ]\)()" "\1${NO_COLOR}" \
  | line.replace "<" "${YELLOW}<" \
  | line.replace ">" ">${GREEN}" \
  | line.replace "#" "${GREEN}#" 

}

c2.function.completion() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$from" "$@" \
  | line.replace "\([^ ]\)().*$" "\1" \
  | line.replace "$name\." \
  | line.replace " {" \
  | line.filter "\.completion" \
  | line.filter "^private" \
  | line.filter "^#" \
  | sort

}

c2.test.absolutePathName() {
  this.absolutePathName "$@"
  echo "${CYAN}${RESULT}"
}

c2.get.function.declaration() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$from" "$1" \
  | grep "$1(" \
  | line.select 1 \
  | line.replace "\([^ ]\)()" "\1" \
  | line.replace " {" \
  | line.unify '#' " no name" " none${NO_COLOR}" " please add a description" \
  | line.format FORMAT_PARSE_METHOD \
  | line.split "|" \
  | line.unquote \
  | line.add "'" >$CONFIG_PATH/current.method.env

  {
    echo declare -- SCRIPT="$from"
    echo declare -- CLASS="$name"
  } >>$CONFIG_PATH/current.method.env

  if [ "$LOG_LEVEL" -gt "3" ]; then
    cat $CONFIG_PATH/current.method.env
  fi
}

c2.get.function.parameter() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.function.declaration "$from" "$1" 

  
  source $CONFIG_PATH/current.method.env

  echo $METHOD_PARAMETER \
  | line.split '<' \
  | line.replace '>' \
  | line.filter "^[ \t\']*$" \
  | line.parse.paramList >$CONFIG_PATH/result.env


  cat $CONFIG_PATH/result.env \
  | line.count \
  | line.format "declare -i PARAMS=%d\n" >>$CONFIG_PATH/result.env

  if [ "$LOG_LEVEL" -gt "3" ]; then
    cat $CONFIG_PATH/result.env
  fi
}


c2.debug.parse.param() {
    cat - \
  | line.unify ':' "parameterName" "addDefaultValue" \

}

c2.completion.enable() { # <cmd> # enables the c2 completion on <cmd>
  local cmd="$1"
  if [ -z "$1" ]; then
    cmd=' '
  fi
  complete -F "c2 complete" "$cmd" -o bashdefault -o default
}

# oo.completion.enable.completion() {
#   compgen -d $OOSH_DIR/$1
# }

c2.completion.discover() {
  console.log "c2 completion.discover $*"
}


c2.usage()
{
  local this=${0##*/}
  echo "You started" 
  echo "$0

  Usage:
  $this: is the next generation completion with regards to function parameter and types"
  this.help
  echo "
      ----      --------------------------
  Examples
    $this v
    $This init
  "
}
c2.init() {
  console.log "c2 init"
  complete -F _c2 c2 -o bashdefault -o default
}

c2.start()
{
  #echo "sourcing init"
  source this
  source line
  #c2.init


  this.start "$@"
}

c2.start "$@"

