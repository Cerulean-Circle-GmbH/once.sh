#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

### new.method


c2.get.functions()  # <script> <functionNameFilter> # lista all functions in a script with description
# functions are identified by someFunctionName( ) but mainly by the brackets ()
# they are parsed till the next curley bracket
# so that this detailed description is part of the grep
{
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  cat "$from" \
  | line.find "[^ ]*$1[^ ]*\(\) " "{" \
  | line.filter "^{" \

  # | line.replace "$name\." \
  # | grep "$1"

  # | line.filter "^#" \
  # | sort \
}

c2.format.functions() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$from" "$@" \
  | line.replace "$" "${NO_COLOR}" \
  | line.replace "^#" "${GREEN}#" \
  | line.replace "$name\." "${CYAN}${name}${NO_COLOR}\." \
  | line.replace "\([^ ]\)()" "\1${NO_COLOR}" \
  | line.replace "<" "${YELLOW}<" \
  | line.replace ">" ">${GREEN}" \
  | line.replace "#" "${GREEN}#" \
  | line.filter "\.completion" \
  | line.filter "^private" 
}

c2.function.completion() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$from" "$@" \
  | line.replace "\([^ ]\)().*$" "\1" \
  | line.replace "$name\." \
  | line.replace " {" \
  | line.filter "\.completion" \
  | line.filter "^private" \
  | line.filter "^#" \
  | sort

}

c2.test.absolutePathName() {
  this.absolutePathName "$@"
  echo "${CYAN}${RESULT}"
}

c2.get.function.declaration() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.functions "$from" "$1" \
  | grep "$1(" \
  | line.select 1 \
  | line.replace "\([^ ]\)()" "\1" \
  | line.replace " {" \
  | line.unify '#' " no name" " none${NO_COLOR}" " please add a description" \
  | line.format FORMAT_PARSE_METHOD \
  | line.split "|" \
  | line.unquote \
  | line.add "'" >$CONFIG_PATH/current.method.env

  {
    echo declare -- SCRIPT="$from"
    echo declare -- CLASS="$name"
  } >>$CONFIG_PATH/current.method.env

  if [ "$LOG_LEVEL" -gt "3" ]; then
    cat $CONFIG_PATH/current.method.env
  fi
}


c2.get.function.parameter() {
  local from="$1"
  if [ -n "$1" ]; then
    from="$1"
    shift
  else
    from="$This"
  fi

  local name=$(basename $from)

  c2.get.function.declaration "$from" "$1" 

  
  source $CONFIG_PATH/current.method.env

  echo $METHOD_PARAMETER \
  | line.split '<' \
  | line.replace '>' \
  | line.filter "^[ \t\']*$" \
  | line.parse.paramList >$CONFIG_PATH/result.env


  cat $CONFIG_PATH/result.env \
  | line.count \
  | line.format "declare -i PARAMS=%d\n" >>$CONFIG_PATH/result.env

  if [ "$LOG_LEVEL" -gt "3" ]; then
    cat $CONFIG_PATH/result.env
  fi
}


c2.debug.parse.param() {
    cat - \
  | line.unify ':' "parameterName" "addDefaultValue" \

}

c2.completion.enable() { # <cmd> # enables the c2 completion on <cmd>
  local cmd="$1"
  if [ -z "$1" ]; then
    cmd=' '
  else
    shift
  fi
  complete  -o nospace -o bashdefault -o default -F "_oo_completion" "$cmd" 
  RETURN="$1"
}

# oo.completion.enable.completion() {
#   compgen -d $OOSH_DIR/$1
# }

c2.completion.discover() {  # <?script> <?method> <?rest> # 
  local argc=$#
  printf "\n"
  #clear -x
  important.log "c2 $* ${RED}$argc" >/dev/tty


  local script="$1"
  if [ -n "$1" ]; then
    shift
  else
    script="$OOSH_DIR/ng/c2"
  fi

  if [ "$script" = "c2" ]; then
    info.log "c2 <?script:$1>" >/dev/tty

    script="$1"
    shift

    if [ "$script" = "-" ]; then
      compgen -f $OOSH_DIR/ | line.replace.sedquoted "${OOSH_DIR}/" >$CONFIG_PATH/result.txt
    else
      compgen -f $OOSH_DIR/ | line.replace.sedquoted "${OOSH_DIR}/" | grep "${script}" >$CONFIG_PATH/result.txt
    fi


    local count=$( cat $CONFIG_PATH/result.txt | line.count )
    info.log "got ${RED}${count}${NO_COLOR} suggestions" >/dev/tty
    if [ $count -le 1 ]; then
      fullscript=$(cat $CONFIG_PATH/result.txt)    
    else 
      return 0
    fi
  fi

  local method="$1"
  info.log "c2 ${YELLOW}<?script:$script> <?method:$method>${NO_COLOR} $*   ${RED}$argc" >/dev/tty
  if [ -z "$fullscript" ]; then
    fullscript="$script"
  fi


  if [ "$script" = "$fullscript" ]; then
    info.log "c2 ${YELLOW}<?script:$fullscript> === <?script:$script>${NO_COLOR} $*   ${RED}$argc" >/dev/tty
  else 
    info.log "c2 ${YELLOW}<?script:$fullscript> =!= <?script:$script>${NO_COLOR} $*   ${RED}$argc" >/dev/tty
    return 0
  fi  

  if [ -n "$1" ]; then
    shift
  fi

  info.log "c2 completion.discover ${YELLOW}<?script:$script> <?method:$method>${NO_COLOR} $*   ${RED}$argc" >/dev/tty

  filter=""
  if ! [ "$method" = "-" ]; then
    filter="$method"
  fi

      # local cur prev opts;
    COMPREPLY=();
    # cur="${COMP_WORDS[COMP_CWORD]}";
    # prev="${COMP_WORDS[COMP_CWORD-1]}";

    script=$( which $script )

    info.log "finding functions in $script containing $method" \
      
    c2.format.functions $script ${filter} \
      | line.replace "\.$method" ".${RED}${method}${NO_COLOR}"  >/dev/tty
    

    c2.function.completion $script ${filter} >$CONFIG_PATH/result.txt


    local count=$( cat $CONFIG_PATH/result.txt | line.count )
    info.log "got ${RED}${count}${NO_COLOR} suggestions" >/dev/tty
    if [ $count -eq 1 ]; then
      fullmethod=$(cat $CONFIG_PATH/result.txt)    
    else 
      return 0
    fi
 
  if [ "$method" = "$fullmethod" ]; then
    important.log "now checking for parameter" >/dev/tty
    c2.get.function.parameter "$script" "$method" 
    source $CONFIG_PATH/current.method.env

    echo "${YELLOW}$METHOD_PARAMETER${NO_COLOR}" \
      | line.replace "[<?]*" \
      | line.split ">" \
      | line.unquote >/dev/tty
  else 
    important.log "c2 completed ${YELLOW}${fullmethod}${NO_COLOR} $*   ${RED}$argc" >/dev/tty
    return 0
  fi  

}


c2.usage()
{
  local this=${0##*/}
  echo "You started" 
  echo "$0

  Usage:
  $this: is the next generation completion with regards to function parameter and types"
  this.help
  echo "
      ----      --------------------------
  Examples
    $this v
    $This init
  "
}
c2.init() {
  console.log "c2 init"
}

c2.install.linux() {
  sudo apt install bash-completion
}

c2.status() # # does not work
{
  console.log "c2 status
  please type 
  
  complete
  
  into the console"
  complete # does not work...has to be in top level interactive shell
  cat /etc/profile.d/bash_completion.sh
}

c2.start()
{
  #echo "sourcing init"
  source this
  source line
  #c2.init


  this.start "$@"
}

c2.start "$@"

