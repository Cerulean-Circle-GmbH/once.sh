#!/bin/bash

# echo "entering: ${BASH_SOURCE[0]}"
# echo "remove all echos to preseve output"
# echo ""

this.functionExists()
{

  local startFunc="$1"
  shift
  RETURN=$1

  if [ "$(type -t $startFunc)" = "function" ]; then
    #info.log "$startFunc exists"
    return 0
  else
    #info.log "$startFunc does not exist"
    return 1
  fi  
} 2>/dev/null

this.load() 
{
  local aFunction=$1
  shift
  local aShellScript=$1
  shift

  if [ -z "$aShellScript" ]; then
    error.log "No script name provided!"
    return 1
  fi

  if (this.functionExists $aShellScript.$aFunction) ; then
    debug.log "$aShellScript was already sourced"
  else
    #important.log "sourcing $aShellScript $aShellScript.$aFunction $@"
    source $aShellScript
    $aShellScript.$aFunction "$@"
  fi
  RETURN=$1
}

if (this.functionExists this.init) ; then
  if (this.functionExists info.log) ; then
    info.log "init was already sourced"
  fi
  return 0
fi

this.init()
{
  info.log "inititlized"
  local initStartPath=$(dirname $(readlink -f "${BASH_SOURCE[0]}"))
  #echo initStartPath $initStartPath
  export PATH=$initStartPath:$PATH
  #loop list PATH
}
this.load v debug

this.absolutePath()
{
  local file=$1
  shift 

  if [ -z "$file" ]; then
    file="$0"
  fi

  result "$(dirname $(readlink -f $file))" "$1"
}

this()
{
  result "${0##*/}" "$1"
}

this.caller()
{
  local len=${#BASH_LINENO[@]}
  local caller=${BASH_SOURCE[3]##*/}
  info.log "script: $0"
  info.log "caller: $caller"
  result "$caller" "$1" >/dev/null
}

this.caller.function()
{
  local function=${FUNCNAME[1]}
  result "$function" "$1" >/dev/null
}

this.call() 
{
  local aFunction=$1
  shift
  
  local len=${#BASH_LINENO[@]}
  local caller=${BASH_SOURCE[$len-2]##*/}
  #info.log "stack : ${BASH_SOURCE[@]}"
  info.log "script: $0"
  info.log "caller: $caller"

  if (this.functionExists $aFunction) ; then
    debug.log "this.call: $aFunction $@"
    $aFunction "$@"
    return "$?"
  else
    info.log "$aFunction does not exist!"
  fi


  if (this.functionExists $caller.$aFunction) ; then
    debug.log "this.call: $caller.$aFunction $@"
    $caller.$aFunction "$@"
  else
    info.log "$caller.$aFunction does not exist!"
    local aShellScript=$aFunction
    aFunction=$1
    shift

    info.log "aShellScript: $aShellScript"
    info.log "aFunction: $aFunction"
    info.log "next parameter \$1: $1"

    if (this.functionExists $aFunction) ; then
      debug.log "this.call: $aFunction $@ "
      $aFunction "$@"
    else
      debug.log "this.load: $aFunction $aShellScript"
      if (this.load $aFunction $aShellScript "$@"); then
        debug.log "done this.call: $aShellScript.$aFunction $@"
        #$aShellScript.$aFunction "$@"
      else
        error.log "this.load faild to load $aShellScript from \"$aFunction\""
        return 127
      fi
    fi
  fi
} #2>/dev/null

this.start() 
{
  if (this.isSourced); then
    debug.log "is sourced"
    return 0
  fi

  if [ -z "$1" ]; then
    local len=${#BASH_LINENO[@]}
    local caller=${BASH_SOURCE[$len-2]##*/}


    if (this.functionExists $caller.usage) then
      $caller.usage
    else
      console.log "$0: no parameter: Bye"
    fi
  fi

  while [ -n $1 ]; do
    debug.log "start 1: -$1-"
    case $1 in
      call)
        shift
        "$@"
        ;;
      discover)
        once.discover
        if [ "$ONCE_STATE" = "disvocer" ]; then
          ONCE_STATE=check.installation
          once.stage
        fi
        ;;
      start)
        stop.log "once start"
        once.server.start "$@"
        ;;
      '')
        debug.log "$0: EXIT"
        #exit 0
        return
        ;;
      *)
        debug.log "this.call to: $@"
        this.call "$@"
    esac

    shift

    while [ ! "$RETURN" = "$1" ]; do
      shift
      debug.log "shift:  -Return:$RETURN-  -$1- -command=$COMMANDS-  =$@="
      if [ -z "$1" ]; then
        debug.log "force stop"
        RETURN=
        exit 0
      fi
    done
    debug.log "found RETURN=$1"
    RETURN=$2
    
  done
  debug.log "will stage"
  this.call "$@"
}


this.isSourced()
{
  len=${#BASH_LINENO[@]}
  depth=1

  info.log "Functions: ${FUNCNAME[@]}"
  info.log "bash source: ${BASH_SOURCE[@]}"
  info.log len=$len, depth=$depth
  info.log "check: ${FUNCNAME[1]}"


    caller=${BASH_SOURCE[$len-2]##*/}
    check=${FUNCNAME[$len-2]}
  if [ $len -gt 3 ]; then
    local caller=${BASH_SOURCE[3]##*/}
    local check=${FUNCNAME[3]}
  fi
  debug.log "caller $caller and mode: $check"

  if [ "$check" = "main" ]; then
    debug.log "mode starting ${FUNCNAME[@]} in ${BASH_SOURCE[0]##*/} from ${BASH_SOURCE[$len-1]##*/}"
    return 1
  else
    debug.log "mode sourcing $caller from ${BASH_SOURCE[$len-1]##*/}" 
    return 0
  fi
}


info.log "
still in ${BASH_SOURCE[0]##*/}
"
#set -x
if (this.isSourced); then
 info.log "init was sourced"
 this.init
else
 important.log "init was started"
 this.init
 warn.log "starting new configured Bash"
 bash
 stop.log "back after closing bash. now in shell level $SHLVL"
fi