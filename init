#!/bin/bash


this.mode() # checks if sourced
{
  local len=${#BASH_LINENO[@]}
  local depth=1
  local Current=${BASH_SOURCE[0]}
  local Caller=${BASH_SOURCE[$depth+1]}
  local current=$(basename $(readlink -f $Current))
  if [ -n "$Caller" ]; then
    local caller=$(basename $Caller)
  else
    local caller=""
  fi
  
  if [ "${FUNCNAME[$depth]}" = "main" ]; then
    echo "starting $current"
    return 0
  else
    echo "sourcing $current"
    return 1
  fi
  echo "\$0: $0"
  echo "\$Current: $Current"
  echo "\$current: $current"
  echo "\$Caller: $Caller"
  echo "\$caller: $caller"
  echo "\$this: $this"
  echo "\$BASH_COMMAND: $BASH_COMMAND"
  echo "Functions: ${FUNCNAME[@]}"
  echo "bash lineno: ${BASH_LINENO[@]}"
  echo "bash source: ${BASH_SOURCE[@]}"
  echo ""
  echo "current   Functions: ${FUNCNAME[$depth]}"
  echo "current bash source: ${BASH_SOURCE[$depth]}"

  if [ -z "$caller" ]; then
    caller="this"
  fi

  local startFunc="$caller.start"
  this.functionExists $startFunc
}

this.functionExists()
{

  local startFunc="$1"
  shift
  RETURN=$1

  if [ "$(type -t $startFunc)" = "function" ]; then
    echo "$startFunc exists"
    return 0
  else
    echo "$startFunc does not exist"
    return 1
  fi  
}


if [ -z "$CONFIG" ];then
  CONFIG=$(config)
  echo "config found: $CONFIG"
fi

if (this.mode); then
 echo "starting configured shell at level $SHLVL"
 bash
 if [ "$SHLVL" = "0" ]; then
   echo "bottom reached...do not exit last bash"
 fi
fi

if (this.functionExists step) ; then
  stop.log "init again"
else
  source $CONFIG
  #source debug
fi
