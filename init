#!/bin/bash

# echo "entering: ${BASH_SOURCE[0]}"
# echo "remove all echos to preseve output"
# echo ""

# export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
# set -x 

if [ -z "$LOG_LEVEL"  ]; then
  export LOG_LEVEL=3
fi

info.log()
{
    if [ "$LOG_LEVEL" -gt "3" ]; then
        echo -e "\033[0mINFO> $*"                                             ## normal
    fi
}

this.isNumber() 
{
  case $1 in
    ''|*[!0-9]*) return 1;;
    *) return 0 ;;
  esac
}

this.functionExists()
{

  local startFunc="$1"
  shift
  RETURN=$1

  if [ "$(type -t $startFunc)" = "function" ]; then
    info.log "$startFunc exists"
    return 0
  else
    info.log "$startFunc does not exist"
    return 1
  fi  
} 2>/dev/null

if (this.functionExists this.load) ; then
  info.log "init was already sourced"
  return 0
fi

this.load() 
{
  local aFunction=$1
  shift
  local aShellScript=$1
  shift

  if [ -z "$aShellScript" ]; then
    error.log "No script name provided!"
    return 1
  fi

  if (this.functionExists $aShellScript.$aFunction) ; then
    info.log "$aShellScript was already sourced"
  else
    #echo "sourcing $aShellScript $aShellScript.$aFunction $@"
    source $aShellScript
  fi
  $aShellScript.$aFunction "$@"
  RETURN=$1
}

check.debug.level()
{
  if [ -n "$1" ]; then
    log.level $1
  fi

  if [ "$LOG_LEVEL" -gt "6" ]; then
    info.log "step Debug ON"
    export STEP_DEBUG=ON 
  else
    export STEP_DEBUG=OFF
  fi

  if [ "$LOG_LEVEL" -gt "5" ]; then
    export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
    set -x
  else
    { 
        set +x
    } 2>/dev/null
  fi

} #2>/dev/null

if ! [ "$(type -t debug.v)" = "function" ]; then
  source debug 
fi  

this.init()
{
  info.log "inititlized"
  local initStartPath=$(dirname $(readlink -f "${BASH_SOURCE[0]}"))
  let shellLevel=$SHLVL-1
  let ooShellLevel=$SHLVL+2
  #echo initStartPath $initStartPath

  # if (loop list PATH find $initStartPath); then
  #   loop list PATH rm $initStartPath
  # fi
  export PATH=$initStartPath:$PATH

  export PS1="[oosh $ONCE_SSH_CONFIG_HOST] $PS1"
  if [ -z "$OOSH_STATUS" ]; then
    export OOSH_STATUS="0: started in shell level: $shellLevel"
    export OOSH_PATH="$initStartPath"
    export OOSH_SHLVL=$ooShellLevel
    export ERROR_CODE_RECONFIG=7
  fi
}

this.init
source $OOSH_PATH/loop
if (loop.list PATH find $OOSH_PATH silent); then
  debug.log "found $OOSH_PATH at $RESULT"
  loop.list PATH rm $OOSH_PATH silent
  debug.log "PATH=$OOSH_PATH:$RESULT"
  export PATH=$OOSH_PATH:$RESULT
fi

result() {
  RETURN_VALUE=$1
  RESULT=$2
  RETURN=$3

  if ! (this.isNumber "$RETURN_VALUE"); then
    export RESULT=$RETURN_VALUE
    RETURN_VALUE=0
  fi
  echo $RETURN_VALUE
}

this.scope()
{
  declare -p
  declare -f | grep "^[^ ]* ()" | cut -d ' ' -f1
}

this.scope.full()
{
  declare -p
  this.scope
}

this.absolutePath()
{
  local file=$1
  shift 

  if [ -z "$file" ]; then
    file="$0"
  fi

  result "$(dirname $(readlink -f $file))" "$1" 2>/dev/null
}

this()
{
  result "${0##*/}" "$1"
}

this.caller()
{
  local len=${#BASH_LINENO[@]}
  local caller=${BASH_SOURCE[3]##*/}
  info.log "script: $0"
  info.log "caller: $caller"
  result "$caller" "$1" >/dev/null
}

this.caller.function()
{
  local function=${FUNCNAME[1]}
  result "$function" "$1" >/dev/null
}

this.call() 
{
  local aFunction=$1
  shift
  
  local len=${#BASH_LINENO[@]}
  local caller=${BASH_SOURCE[$len-2]##*/}
  #info.log "stack : ${BASH_SOURCE[@]}"
  info.log "script: $0"
  info.log "caller: $caller"

  if (this.functionExists $aFunction) ; then
    debug.log "this.call: $aFunction $@"
    $aFunction "$@"
    return "$?"
  else
    info.log "$aFunction does not exist!"
  fi


  if (this.functionExists $caller.$aFunction) ; then
    debug.log "this.call: $caller.$aFunction $@"
    $caller.$aFunction "$@"
  else
    info.log "$caller.$aFunction does not exist!"
    local aShellScript=$aFunction
    aFunction=$1
    shift

    info.log "aShellScript: $aShellScript"
    info.log "aFunction: $aFunction"
    info.log "next parameter \$1: $1"

    if (this.functionExists $aFunction) ; then
      debug.log "this.call: $aFunction $@ "
      $aFunction "$@"
    else
      debug.log "this.load: $aFunction $aShellScript"
      if (this.load $aFunction $aShellScript "$@"); then
        debug.log "done this.call: $aShellScript.$aFunction $@"
        #$aShellScript.$aFunction "$@"
      else
        error.log "this.load faild to load $aShellScript from \"$aFunction\""
        return 127
      fi
    fi
  fi
} #2>/dev/null

this.start() 
{
  if (this.isSourced); then
    debug.log "is sourced"
    return 0
  fi

  if [ -z "$1" ]; then
    local len=${#BASH_LINENO[@]}
    local caller=${BASH_SOURCE[$len-2]##*/}


    if (this.functionExists $caller.usage) then
      $caller.usage
    else
      console.log "$0: no parameter: Bye"
    fi
  fi

  while [ -n $1 ]; do
    debug.log "start 1: -$1-"
    case $1 in
      call)
        shift
        "$@"
        ;;
      discover)
        once.discover
        if [ "$ONCE_STATE" = "disvocer" ]; then
          ONCE_STATE=check.installation
          once.stage
        fi
        ;;
      start)
        stop.log "once start"
        once.server.start "$@"
        ;;
      '')
        debug.log "$0: EXIT"
        #exit 0
        return
        ;;
      *)
        debug.log "this.call to: $@"
        this.call "$@"
    esac

    shift

    while [ ! "$RETURN" = "$1" ]; do
      shift
      debug.log "shift:  -Return:$RETURN-  -$1- -command=$COMMANDS-  =$@="
      if [ -z "$1" ]; then
        debug.log "force stop"
        RETURN=
        exit 0
      fi
    done
    debug.log "found RETURN=$1"
    RETURN=$2
    
  done
  debug.log "will stage"
  this.call "$@"
}


this.isSourced()
{
  # test.isSourced this.isSourced \ this.isSourced main                                               => called by main            and started
  # init this.isSourced           \ this.isSourced main                                               => called by main            and started
  # this.call this.isSourced      \ this.isSourced this.call main                                     => called by this.call       and sourced
  # test.case source              \ this.isSourced this.start mycmd.start source test.case main       => called by this.start      and sourced from test.case
  # mycmd.feature3 hello world    \ this.isSourced mycmd.feature3 test.case main                      => called by mycmd.feature3


  caller=${BASH_SOURCE[1]##*/}
  callerFunction=${FUNCNAME[1]}

  case $callerFunction in
      "main") #started
        result 1 "started by $callerFunction in $caller" 
        ;;
      "this.call") #called therfore sourced
        result 0 "sourced because called by $callerFunction in $caller"
        ;;
      "this.start") #started depending on command [3]
        if [ "${FUNCNAME[3]}" = "source" ]; then
          result 0 "sourced because called by $callerFunction in $caller" >/dev/null
        else
          result 1 "started by ${FUNCNAME[4]} in ${BASH_SOURCE[4]##*/}" >/dev/null
        fi
        ;;
      "*") #called therfore sourced
            result 0 "sourced because called by $callerFunction in $caller" >/dev/null
  esac
  return $RETURN_VALUE
}


info.log "
still in ${BASH_SOURCE[0]##*/}
"
#set -x
if (this.isSourced); then
 info.log "init was sourced"

else
 info.log "init was started as $0"


 #export LOG_LEVEL=6

 #stop.log "starting new configured Bash"
 export PS1="[$ONCE_SSH_CONFIG_HOST] \[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[0m\] > "
 cd "$OOSH_PATH"
 bash
 RETURN_VALUE=$?
 if [ "$RETURN_VALUE" -eq "$ERROR_CODE_RECONFIG" ]; then
  echo "applying new configuration"
  bash
 fi
 if [ "$SHLVL" = "$OOSH_SHLVL" ]; then
  warn.log "on exit you will loose OOSH features."
 fi
 echo "back after closing bash. now in shell level $SHLVL"
fi