#!/bin/bash

# echo "entering: ${BASH_SOURCE[0]}"
# echo "remove all echos to preseve output"
# echo ""

source init
this.load checkDebug log

debug.v() {
  info.log "${BASH_SOURCE[@]##*/} version 2021-10-19 15:25"
}

function step()
{

  { 
      set +x
  } 2>/dev/null

    #info.log "step on level $LOG_LEVEL"
    if [ -z "$LOG_LEVEL" ]; then
        LOG_LEVEL=5
        export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
    fi

  if [ "$STEP_DEBUG" = "ON" ]; then

    echo -e "\033[37m+<-----------------------------------------"
    echo "> function ${FUNCNAME[1]}(" "${BASH_ARGV[@]}" ")  in file: ${BASH_SOURCE[1]}"
    echo -e "> line: ${BASH_LINENO[1]} '${BASH_COMMAND}'\033[0m"

    read -p '' CONT

    if [[ ! "$CONT" = "" ]]; then
      case $CONT in
        h)
            echo "
            h     this help
            e     expands variable in the command
            n     next command full with debug
            ENTER next command

            d     toggle debug messages
            t     trace the stack
            s     continue silently
            c     with debug
            p     print PATH
            ll    list dir
            cd    changing to entered path
            root  tree /root
            home  tree /home
            i     check eamd
            eamd  tree workspace

            cmd   runn command (BE CAREFULL)

            q     exit
                all other commands exit too
            "
            step
            ;;
        s)
            log.checkDebug 1
            ;;
        n)
            log.checkDebug 6
            echo "ENTER: continue"
            export STEP_DEBUG=ON
            return 0
            ;;
        x)
            log.checkDebug 6
            ;;
        c)
            log.checkDebug 5
            ;;
        e)
            echo "> expands to: $(eval echo "$BASH_COMMAND")"
            step
            ;;
        r)
            export STEP_TILL_NEXT_RETURN=ON
            removeTrap
            warn.log "continue till next Return"
            step
            ;;
        t)
            stackTrace
            ;;
        ls)
            ls -al
            step 
            ;;
        d)
            toggleDebug
            step
            ;;
        p)
            console.log "PATH=$PATH"
            step
            ;;
        ll)
            pwd
            ls -alF
            step
            ;;
        root)
            tree -aL 2 /root
            step
            ;;
        home)
            tree -aL 2 /home
            step
            ;;
        eamd)
            tree -aL 2 /$defaultWorkspace/..
            step
            ;;
        i)
            eamd check
            step
            ;;
        cd)
            read -p 'cd to?   >' CD_DIR
            cd $CD_DIR
            step
            ;;
        cmd)
            read -p 'command?  BE CAREFULL >' command
            set -x
            $command
            step
            ;;    
        env)
            read -p 'ENV VARIBALE NAME>' env
            set -x
            echo -e "\033[1;33mexport $env=${!env}\033[0m"
            step
            ;;          
        *)
            warn.log "FORCE EXIT because of command: $CONT"
            exit 0
      esac
    else
      echo "ENTER: continue"
      export STEP_DEBUG=ON
      return 0
    fi
  #else
    #echo "Step Debug is $STEP_DEBUG"
  fi
 
  log.checkDebug
    
}

function stackTrace() {
            i=0;
            #for (( i=0; i<=${#BASH_LINENO[@]}; i++)); do
            echo -e "\033[1;37m" 
            for l in ${BASH_LINENO[@]}; do
                printf "i: %2d  line: %6d  function: %-20s  file: %-30s   args: " "$i" "$l" "${FUNCNAME[$i]}()" "${BASH_SOURCE[$i]}"
                echo "\"${BASH_ARGV[@]}\" and \"$@\""
                ((i++))
            done
            echo -e "\033[0m"
            step
}

function toggleDebug() {
    if [ "$LOG_LEVEL" -gt "4" ]; then
      log.checkDebug 3
      export STEP_DEBUG=OFF
    else
      log.checkDebug 5
      export STEP_DEBUG=OFF
    fi
    warn.log "Toggeld DEBUG to $DEBUG"
}

function onReturn() {
    debug.log "function ${FUNCNAME[1]} returned with code: $1 and $2 RESTULT=$RESTULT"
    if [ "$0" = "$2" ]; then
        #do not stop when in this $0 debug file $2
        return 0
    fi
    
    if [ "ON" = "$STEP_TILL_NEXT_RETURN" ]; then 
        STEP_TILL_NEXT_RETURN=OFF
        export STEP_DEBUG=ON
        #set +x
    fi
    #current.context
#   if [ -z "$2" ]; then
#     RETURN=$2
#   fi
}

function onError() {
  #echo -e "\033[1;31m   line: ${BASH_LINENO[2]} '${BASH_COMMAND[2]}'\033[0m"

  if [ "$1" = "1" ]; then
    return
  fi

    error.log         "function ${FUNCNAME[1]} in line: ${BASH_LINENO[2]} from ${BASH_SOURCE[2]} returned with ERROR code: $1"
    if [ "ON" = "$DEBUG" ]; then
      export STEP_DEBUG=
      stackTrace
      export STEP_DEBUG=ON
    fi
}

function onExit() {
  debug.log "exiting"
}


function setTrap() {
  #echo "trap DEBUG set to step"

  #export PS4='\033[90m+${LINENO}: '

  trap step DEBUG
  #set -e
  trap 'onError ${?}' ERR
  trap 'onReturn ${?}' RETURN
  trap 'onExit  ${?}' EXIT 
}

setTrap