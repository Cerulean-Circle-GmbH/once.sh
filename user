#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

user.id.completion() {
  echo "-u -n" 
  echo "-g"
}

user.id()
{
  id "$@"
}

user.ssh.status.completion() {
  echo log
}

user.ssh.status()
{
  if [ -f ~/.ssh/id_rsa ]; then
    create.result 0 "ssh is initialized for $USER" "$1"
  else
    create.result 1 "ssh does not exist for $USER" "$1"
  fi

  if [ "$1" == "log" ]; then
    shift
    console.log "$RESULT" 
    RETURN=$1
  fi
  return "$(result)"
}

user.in() {
  CURRENT_SSH_DIR="$1"
  if [ -n "$1" ]; then
    shift
  fi

  if [ -z "$1" ]; then
    CURRENT_SSH_DIR="$HOME/.ssh"
  fi
  RETURN="$1"
}

private.get.sshDir() {
  local sshDir="$1"
  if [ -z "$1" ]; then
    sshDir="$CURRENT_SSH_DIR"
  fi
  if [ -z "$sshDir" ]; then
    sshDir="$HOME/.ssh"
  fi
  shift

  create.result 0 "$sshDir" "$1"
  info.log "$RESULT"
  return $(result)
}

user.ssh.get.key.name() {
  local sshKeyName="$SSH_KEY_NAME"

  # if [ -z "$SSH_KEY_NAME" ]; then
  #   source config
  #   config.load ssh.info
  # fi

  if [ -z "$sshKeyName" ]; then
    user.ssh.set.key.name "$USER.$(hostname -f)"
  fi

  create.result 0 "$RESULT" "$1"
  console.log "$RESULT"
  return $(result)
}

user.ssh.set.key.name() {
  local sshKeyName="$1"
  if [ -z "$sshKeyName" ]; then
    export SSH_KEY_NAME="$USER.$(hostname -f)"
  fi
  config save "ssh.info" "SSH_" >/dev/null
  stop.log "$SSH_KEY_NAME - $sshKeyName"
  create.result 0 "$sshKeyName" "$1"
  return $(result)
}

user.ssh.get.file.name() {
  local sshDir="$1"
  if [ -z "$1" ]; then
    sshDir="$CURRENT_SSH_DIR"
  fi
  if [ -z "$sshDir" ]; then
    sshDir="$HOME/.ssh"
  fi
  shift


  local sshKeyName="$(ls $sshDir/private_key/ | sed 's/\.private_key//')"

  create.result 0 "$sshKeyName" "$1"
  console.log "$RESULT"
  return $(result)
}

user.ssh.rootkey.push() {
  local sshConfigName="$1"
  # if [ -z "$1" ]; then
  #   sshConfigName="$CURRENT_SSH_DIR"
  # fi
  # if [ -z "$sshDir" ]; then
  #   sshDir="$HOME/.ssh"
  # fi
  shift

  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"

  user.ssh.get.file.name $sshDir
  if [ -n "$1" ]; then
    shift
  fi
  local sshKeyName="$RESULT"

  scp $sshDir/public_keys/$sshKeyName.public_key $sshConfigName:/root/.ssh/public_keys
  ssh $sshConfigName ". /root/config/user.env; user update.authorized_keys"
}

user.ssh.rootkey.file.push() {
  local sshConfigName="$1"
  # if [ -z "$1" ]; then
  #   sshConfigName="$CURRENT_SSH_DIR"
  # fi
  # if [ -z "$sshDir" ]; then
  #   sshDir="$HOME/.ssh"
  # fi
  shift

  local sshPublicKeyFile="$1"
  if [ -n "$sshPublicKeyFile" ]; then
    shift
    scp $sshPublicKeyFile $sshConfigName:/root/.ssh/public_keys
    ssh $sshConfigName ". /root/config/user.env; user update.authorized_keys"
  else
    error.log "no public key file provided as second parameter"
  fi


}

user.ssh.rootkey.file.revoke() {
  local sshConfigName="$1"
  # if [ -z "$1" ]; then
  #   sshConfigName="$CURRENT_SSH_DIR"
  # fi
  # if [ -z "$sshDir" ]; then
  #   sshDir="$HOME/.ssh"
  # fi
  shift

  local sshPublicKeyFile="$1"
  if [ -n "$sshPublicKeyFile" ]; then
    shift
    ssh $sshConfigName ". /root/config/user.env; mv  /root/.ssh/public_keys/$(basename $sshPublicKeyFile)  /root/.ssh/deactive.public_keys/$(basename $sshPublicKeyFile);    user update.authorized_keys"
  else
    error.log "no public key file provided as second parameter"
  fi


}


user.ssh.rootkey.pull() {
    local sshConfigName="$1"
  # if [ -z "$1" ]; then
  #   sshConfigName="$CURRENT_SSH_DIR"
  # fi
  # if [ -z "$sshDir" ]; then
  #   sshDir="$HOME/.ssh"
  # fi
  shift



  scp $sshConfigName:/root/.ssh/id_rsa.pub ./root.$sshConfigName.public_key
  #ssh $sshConfigName ". /root/config/user.env; user update.authorized_keys"
}

user.ssh.rootkey.push.completion() {
  grep '^Host' ~/.ssh/config ~/.ssh/config.d/* 2>/dev/null | cut -d ' ' -f 2-
}

user.ssh.rename.files() {
  user.ssh.get.file.name
  local sshKeyFileName="$RESULT"

  local sshKeyName="$1"
  if [ -z "$sshKeyName" ]; then
    user.ssh.get.key.name
    sshKeyName="$RESULT"
  fi
  shift

  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"

  #ls -al $sshDir/public_keys/${sshKeyFileName}*
  #ls -al $sshDir/private_key/${sshKeyFileName}*

  mv $sshDir/private_key/${sshKeyFileName}.private_key $sshDir/private_key/${sshKeyName}.private_key
  mv $sshDir/public_keys/${sshKeyFileName}.public_key $sshDir/public_keys/${sshKeyName}.public_key 

  tree $sshDir

}

user.ssh.init()
{
  if user.ssh.status log; then
    console.log ".ssh exists"
    tree ~/.ssh
  else
    console.log "initialising new .ssh"
    ssh-keygen
    mkdir ~/.ssh/public_keys
    mkdir ~/.ssh/private_key
    user.ssh.get.key.name
    local sshKeyName="$RESULT"
    cp ~/.ssh/id_rsa ~/.ssh/private_key/$sshKeyName.private_key
    cp ~/.ssh/id_rsa.pub ~/.ssh/public_keys/$sshKeyName.public_key
    {
      echo "
Host WODA.test
 User root
 Port 22
 HostName 178.254.18.182
 IdentityFile ~/.ssh/id_rsa

Host WODA.dev.root
 User root
 Port 22
 HostName cerulean.it
 IdentityFile ~/.ssh/id_rsa
 
Host WODA.dev
 User developking
 Port 22
 HostName cerulean.it
 IdentityFile ~/.ssh/id_rsa
      "

    } >~/.ssh/config
  oo cmd tree >/dev/dull
  tree ~/.ssh
  fi
}

user.ssh.create.folders() {
  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"
  
  mkdir  $sshDir/public_keys                                      
  mkdir $sshDir/private_key
  user.ssh.get.key.name                                   
  local sshKeyName="$RESULT"
  cp $sshDir/id_rsa $sshDir/private_key/$sshKeyName.private_key
  cp $sshDir/id_rsa.pub $sshDir/public_keys/$sshKeyName.public_key
}


user.update.authorized_keys()
{

  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"

  if user.ssh.status; then
    info.log "updating $sshDir/authorized_keys"
    rm $sshDir/authorized_keys
    cat $sshDir/public_keys/* >>~/.ssh/authorized_keys

    chmod 770 $sshDir
    chmod 600 $sshDir/authorized_keys
  fi
}

user.create()                   # expects "name <uid gid>" and creates a new user with home dir
{

  local name=$1
  local custom_uid=
  local custom_gid=
  shift
  if [ -n "$1" ]; then
    custom_uid=$1
    shift
  fi
  if [ -n "$1" ]; then
    custom_gid=$1
    shift
  fi

  if [ -d $REPO_DIR ]; then
    warn.log "Repository does not exist: $REPO_DIR"
  fi

  if [ -n "$custom_uid" ]; then
    $ONCE_SUDO useradd -m $name -u$custom_uid -g$custom_gid -s /bin/bash
  else
    $ONCE_SUDO useradd -m $name -s /bin/bash
  fi
  $ONCE_SUDO usermod -aG sudo $name
  useradd -g dev $name 
  #once.user.init $name
  

  RETURN=$1

}

user.check.group() {
  local group=$1
  shift 
  if [ $(getent group admin) ]; then
    create.result 0 "group $group exists" "$1"
  else
    create.result 1 "group $group does not exist"  "$1"
  fi
  console.log "$RESULT"
  return "$(result)"
}

user.list() {
  compgen -u "$1"
}

user.list.groups() {
  compgen -g "$1"
}

user.ssh.backup() {
  local name="$1"
  if [ -z "$name" ]; then
    name="bak"
  fi
  if [ -n "$1" ]; then
    shift
  fi

  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"

  cp -R $sshDir ssh.$name 
}

user.ssh.restore() {
  local name="$1"
  if [ -z "$name" ]; then
    name="bak"
  fi
  if [ -n "$1" ]; then
    shift
  fi

  private.get.sshDir "$1"
  if [ -n "$1" ]; then
    shift
  fi
  local sshDir="$RESULT"

  cp -R ssh.$name $sshDir 
}

user.usage()
{
  local this=${0##*/}
  echo "You started 
$0
  
  Usage:
  $this: command   description and Parameter

      usage                   prints this dialog while it will print the status when tehere are no parameters          
      v                       print version information

      in 
  
      list  
      create                  expects \"name <uid gid>\" and creates a new user with home dir
      update.authorized_keys  <?sshDir:\"~/.ssh\">
  
      ssh.status log          logs if ther is an ssh config
      ssh.init                creates a new ssh config
  
      ssh.rename.files        <newName> <?sshDir:\"~/.ssh\">
      ssh.get.key.name      
      ssh.get.file.name       <?sshDir:\"~/.ssh\">

      ssh.backup              <newName> <?sshDir:\"~/.ssh\"> will result in a ssh.newName folder
      ssh.restore             <newName> <?sshDir:\"~/.ssh\"> CAREFULL!!! ssh.newName in sshDir and if not present overwites the current .ssh folder

      ssh.rootkey.file.revoke <sshConfigName> <publicKeyFile>      revokes access for the public key file
      ssh.rootkey.file.push   <sshConfigName> <publicKeyFile>      pushes the public key file        to the root of the specified ssh server and makes it authorized
      ssh.rootkey.push        <sshConfigName> <?sshDir:\"~/.ssh\"> pushes the public key from sshDir to the root of the specified ssh server and makes it authorized
      ssh.rootkey.pull        <sshConfigName> gets the root public key of the specified ssh server
  
  Examples
    $this v
    $this init

    user in ./KPP/ssh.developer ssh.get.file.name
    user ssh.get.file.name ./KPP/ssh.developer

  OS details:
      OS_CMD_USER_ADD=$OS_CMD_USER_ADD
      OS_CMD_USER_MDO=$OS_CMD_USER_MOD  
      OS_CMD_USER_DEL=$OS_CMD_USER_DEL
  "
}

private.user.init() {
  if [ -z "$USER" ]; then
    USER=$(id -u -n)
  fi
  ONCE_SUDO=sudo

  if [ -x "$(command -v adduser)" ]; then
    OS_CMD_USER_ADD=adduser
  fi
  if [ -x "$(command -v useradd)" ]; then
    OS_CMD_USER_ADD=useradd
  fi
  if [ -x "$(command -v userdel)" ]; then
    OS_CMD_USER_DEL=userdel
  fi
  if [ -x "$(command -v usermod)" ]; then
    OS_CMD_USER_MOD=usermod
  fi
}

user.start()
{
  #echo "sourcing init"
  source this
  private.user.init

  # if [ -z "$1" ]; then
  #   status.discover "$@"
  #   return 0
  # fi

  this.start "$@"
}

user.start "$@"

