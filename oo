#!/usr/bin/env bash
#clear
#export PS4='\e[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \e[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"


oo.deinstall() { # # deinstall oosh and clean leftover configurations
  problem.log "DEINSTALL OOSH: are you sure?  continue with by typing 'c'"
  cp $OOSH_DIR/init/oosh $HOME/install.oosh
  rm -Rf $HOME/oosh
  rm -Rf $HOME/config
  rm $HOME/.once
  rm $HOME/.bashrc
  mv $HOME/.bashrc.bak.without.completion $HOME/.bashrc
  clear
  echo "reinstall with: install.oosh"
}

oo.new() # <newClassName> # creates a new script that acts as a oo class with completion
{
  if [ -n "$1" ]; then
    info.log "oosh in $OOSH_DIR"
    cd $OOSH_DIR
    cat ./templates/code/new_script | sed 's/new_script/'"$1"'/' >./$1
    chmod +x ./$1
    success.log "created oo script $1"
    important.log "to enable completion on the new command, type

    reconfigure"

    cd $OOSH_DIR/test
    cat ./../templates/code/new_script_test | sed 's/new_script/'"$1"'/' > test.$1
    chmod +x ./test.$1
    success.log "created test script test.$1"

  else
    warn.log "usage: oo new filename
    
    please specify a filename"
    return 1
  fi
}

oo.new.method()   # <new.method> <new_script.new_method> # creates a new method in the script new_script
# this is an higly interactive command
{
  local name="$1"
  if [ -z "$name" ]; then
    error.log "No parameter provided."
    return 1
  fi
  local new_script=$(echo $name | cut -d. -f1)
  local new_method=$(echo $name | cut -d. -f2)
  
  if [ -z "$new_method" ]; then
    warn.log "check if the parameter contains a ."
    error.lgo "no method name in: $name:"
    return 2
  fi
  console.log "
  command: $new_script
  method : $new_method
  "

  if check file $OOSH_DIR/$new_script exists fix error.log "$OOSH_DIR/$new_script does not exist"
  then
    local tweaked_method=$(cat $OOSH_DIR/templates/code/new_method | sed 's/new_script/'"$new_script"'/' | sed 's/new_method/'"$new_method"'/')
    local replace_text="### new.method"

    replace within "$OOSH_DIR/$new_script" "$replace_text" by "$tweaked_method"

    local parameters
    echo "Give the possible parameter(s) for the method" $new_method "of the script" $new_script": "
    read parameters
    info.log "$parameters"
    
    replace within "$OOSH_DIR/$new_script.new" "parameters" by "$parameters"

    local description
    echo "Give a description of the method" $new_method "in the script" $new_script": "
    read description
    info.log "$description"
    
    replace within "$OOSH_DIR/$new_script.new" "method description" by "$description"


    local replace_eg="    ----------"
    local new_eg="    ----------
    ----------"

    replace within "$OOSH_DIR/$new_script.new" "$replace_eg" by "$new_eg"

    local example
    echo "Give example parameters of the method" $new_method ", of the script" $new_script": "
    read example
    info.log "$example"

    sed -i '0,/----------/{s/----------/'"\$this $new_method $example"'/}' $OOSH_DIR/$new_script.new

    replace commit "$OOSH_DIR/$new_script"

    replace cleanup "$OOSH_DIR/$new_script"

    success.log "created oo new method called $new_method in script $new_script"
    
  fi

  if check file $OOSH_DIR/test/test.$new_script exists fix error.log "$OOSH_DIR/test/test.$new_script does not exist"
  then
    local tweaked_test_method=$(cat $OOSH_DIR/templates/code/new_method_test | sed 's/new_script/'"$new_script"'/' | sed 's/new_method/'"$new_method"'/')
    local replace_test_text="### test.method"

    replace within "$OOSH_DIR/test/test.$new_script" "$replace_test_text" by "$tweaked_test_method"

    local test_description
    echo "Give a short description of the respective test of the method" $new_method "in the script" $new_script": "
    read test_description
    info.log "$test_description"

    replace within "$OOSH_DIR/test/test.$new_script.new" "test_description" by "$test_description"

    #sed -i '0,/test_description/{s/test_description/'"$test_description"'/}' $OOSH_DIR/test/test.$new_script.new

    local test_parameter
    echo "Give the parameters of the method" $new_method "to be used in this respective test, in the script" $new_script": "
    read test_parameter
    info.log "$test_parameter"

    replace within "$OOSH_DIR/test/test.$new_script.new" "new_arguments" by "$test_parameter"

    #sed -i '0,/new_argument(s)/{s/new_argument(s)/'"$test_parameter"'/}' $OOSH_DIR/test/test.$new_script.new

    local test_expect
    echo "What do you expect the test of the method" $new_method "in the script" $new_script" to return? "
    read test_expect
    info.log "$test_expect"

    replace within "$OOSH_DIR/test/test.$new_script.new" "new_expect" by "$test_expect"

    #sed -i '0,/new_expect/{s/new_expect/'"$test_expect"'/}' $OOSH_DIR/test/test.$new_script.new
    
    replace commit "$OOSH_DIR/test/test.$new_script"

    replace cleanup "$OOSH_DIR/test/test.$new_script"

    success.log "created new test called test.$new_script for method $new_method in script $new_script"
    
  fi

}



oo.commit() # # commits latest changes to the oosh environment and publishes them.
{
  cd $OOSH_DIR

  local branch=$( git branch | line find "\*" )
  important.log "git barnch is: $branch"
  if [ "$branch" = "* dev" ]; then

  git add *
  git commit
  git push
  else
    error.log "not on the dev branch"
    important.log "switch branch with
   
    oo mode.dev
    
    "
  fi
}

oo.update() # # updates oosh environment and pulls latest changes from github.
{
  cd $OOSH_DIR
  git pull
}

oo.remote.update() { # <sshConfigHost> # updates the oosh environment on <sshConfigHost>
  local sshConfigHost="$1"
  if [ -n "$1" ]; then
    shift
  else
    error.log "no sshConfigHost was specified"
    return 1
  fi
  ossh exec "$sshConfigHost" "oo update"
}
oo.remote.update.completion() {
  ossh config.get.completion
}

oo.release() { # # RELEASES and merges dev to prod. NEVER merge main to dev
  oo.stage.to.prod
}

oo.stage.to.prod() # # RELEASES and merges dev to prod
{
  oo.commit
  git checkout main
  git merge dev
  git push
  export OOSH_MODE="released"
  config save oosh OOSH
}

oo.mode.dev() # # switches to dev branch
{
  cd $OOSH_DIR
  git pull
  git checkout dev
  git push
  export OOSH_MODE="dev"
  config save oosh OOSH
}

oo.mode() # # shows branch status
{
  cd $OOSH_DIR
  source $CONFIG_PATH/oosh.env
  GIT_PUSH_ORIGIN="$( git remote -v | line find push | line split "git" | line 'select' 3 | line unquote )"
  
  if [ "$GIT_PUSH_ORIGIN" = 'hub.com:Cerulean-Circle-GmbH/once.sh.' ]; then
    important.log "push origin correct"
  else
    warn.log "push origin wrong: 
    
    is         [$( git remote -v | line find push )] 
    should be  [origin     git@github.com:Cerulean-Circle-GmbH/once.sh.git (push)] 

    please do git clone with ssh url that starts with: git clone git@github..."
  fi
  git status
  important.log "OOSH_MODE=$OOSH_MODE"
}

oo.state() # # initializes the stae machine or shows the current state if already initialized
{
  local machine=SETUP_SERVER


  if state machine.exists ${machine}; then
    state of ${machine} list all
    source $CONFIG_PATH/current.state.machine.env
    if [ $state -lt 4 ]; then
      state machine.start - oo
    fi
  else
      debug.log "initalize ${machine}"
      private.init.state.machine ${machine}
  fi
}

private.init.state.machine() # <machine> # creates the state machine
{
  local machine=$1
  important.log "initialising state machine: ${machine}"
  
  source $OOSH_DIR/state

  state.machine.create ${machine} oo
  state.add remote.install.started               silent 
  state.add local.install.started                silent 
  state.add priviledges.checked                  silent 
  state.add 20                                   silent 
  state.add user.rights.only                     silent
  state.add user.installation.done               silent
  state.add user.mode.release                    silent
  state.add user.mode.dev                        silent
  state.add 30                                   silent  
  state.add root.rights                          silent 
  state.add root.shared.dev.folder.created       silent 
  state.add root.dev.keys.installed              silent 
  state.add root.installation.done               silent 
  state.add 40                                   silent 
  state.add user.shared.dev.folder.linked        silent 
  state.add user.state.machine.synced.with.root  silent 
  state.add 50                                   silent 
  state.add headless.setup.started               silent 
  state.add headless.setup.finished              silent 
  state.add 60                                   silent 
  state.add once.setup.started                   silent 
  state.add once.setup.finished                  silent 

  state.next
  state.machine.start oo
  state.next
  state.next
  state.list

  #state.add - does.not.work
}

private.check.priviledges.checked() # # RESULT will be the follow up state
{
  if [ "$USER" = "root" ]; then
    create.result 0 "30"
  else
    create.result 1 "user privilidges"
    if private.test.sudo.priviledges; then
      # RESULT will be the follow up state: [30]="root.rights""
      create.result 0 "30"
    else
      # RESULT will be the follow up state: [20]="user.rights.only"
      create.result 1 "20"
    fi
  fi

}

private.test.sudo.priviledges() {
  if [ -f ~/.sudo_as_admin_successful ]; then
    create.result 0 "sudo privilidges active"
    return $(result)
  else
    if [ -n "$SUDO" ]; then
      $SUDO touch ~/.sudo_as_admin_successful
      if [ -f ~/.sudo_as_admin_successful ]; then
          rm ~/.sudo_as_admin_successful
          create.result 0 "sudo privilidges by password"
          return $(result)
      fi
    fi
  fi
  create.result 1 "no sudo privilidges"
  return $(result)
}

private.check.user.rights.only() {
  source state
  state.check SETUP_SERVER priviledges.checked oo
  if [ "$RESULT" = "20" ]; then
    create.result 0 "20"
    return $(result)
  fi
  if [ "$RESULT" = "30" ]; then
    create.result 0 "30"
    return $(result)
  fi
  create.result 1 "Something went wrong! \n$RESULT"
  return $(result)
}

private.check.local.install.started() {
  if [ -f "$OOSH_DIR/this" ]; then
    create.result 0 "$OOSH_DIR/this exists"
  else
    create.result 1 "$OOSH_DIR/this does not exist"
  fi
}

private.check.user.installation.done() {
  if [ -d $HOME/oosh ]; then
    create.result 0 "$HOME/oosh exists"
  else
    create.result 1 "$HOME/oosh does not exist"
  fi
}

private.check.root.rights() {
  source state
  state.check SETUP_SERVER priviledges.checked oo
  if [ "$RESULT" = "20" ]; then
    create.result 1 "21"
    return $(result)
  fi
  if [ "$RESULT" = "30" ]; then
    create.result 0 "30"
    return $(result)
  fi
  create.result 1 "Something went wrong! \n$RESULT"
  return $(result)
}

private.check.remote.install.started() {
  if [ -n "$SSH_CONFIG_FROM_REMOTE" ]; then
    success.log "
    
    Remote installation started from  : $SSH_CONFIG_FROM_REMOTE
    Remote name used for this machine±: $SSH_CONFIG_NAME_USED_FOR_LOCAL
    "
    create.result 0 12 $1
  else
    warn.log "SSH_CONFIG_FROM_REMOTE not set. No remote installation detected"
    success.log "remote.install.started: continue with local install"
    create.result 0 12 $1
  fi
  return $(result)
}
private.check.user.mode.release() {
  if [ "$OOSH_MODE" = "released" ]; then
    create.result 0 "OOSH_MODE=$OOSH_MODE"
  else
    create.result 1 "not in mode released!   OOSH_MODE=$OOSH_MODE"
  fi
  return $(result)
}
private.check.user.mode.dev() {
  if [ "$OOSH_MODE" = "dev" ]; then
    create.result 0 "OOSH_MODE=$OOSH_MODE"
  else
    create.result 1 "not in mode: dev!   OOSH_MODE=$OOSH_MODE"
    important.log "
    
    you can switch there manualy with
    
    oo mode.dev
    "
  fi
  return $(result)
}

private.check.root.shared.dev.folder.created() {
  #check.debug.level 6
  #source user
  user get home
  
  if [ ! "$USER" = "root" ]; then
    local currentHome="$( user get home $USER )"
    this.absolutePath "$currentHome/.."
    debug.log "absolutePath of \"$currentHome\..\": $RESULT"
    local dir="$RESULT"
    important.log "dir=$dir"
    local currentUser=$( echo $currentHome | line replace.sedquoted "$dir/")
    important.log "currentUser=$currentUser"

    error.log "This state can only be executed by root
    
    please provide your sudo password to install oosh into root"
    sudo ~/oosh/init/oosh mode user user.$USER localhost dev   

    config list
    sudo chown -R developking:dev "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    sudo chmod -R g+w "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    user group.add dev $paramerUser

    #problem.log "check config"


    create.result $? "installed root form user $user" "$1"
    return $(result)
  fi
  
  #set -x

  local devHome="$( user get home developking )"
  if [ -z "$devHome" ]; then
    user create developking
    user group.add dev developking
    devHome="$( user get home developking )"
  fi
  echo  "absolutePath of \"$devHome\..\"..."
  this.absolutePath "$devHome/.."
  debug.log "absolutePath of \"$devHome\..\": $RESULT"
  local dir="$RESULT"
  important.log "dir=$dir"
  
  #return 2
  
  if [ -d "$dir/shared/dev" ];then
    success.log "$dir/shared/dev exists"
  else
    console.log "creating $dir/shared/dev"
    mkdir -p "$dir/shared/dev/Workspaces"
    mkdir -p "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/main/"
    mkdir -p "$dir/shared/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/Once.sh"

    $SUDO user group.add dev $USER
    #cp -r $HOME/oosh "$dir/shared/dev/."
    
    
    $SUDO chown -R developking:dev "$dir/shared/dev/"
    #find "$dir/shared/dev/oosh" -type d -print0 | xargs -0 chmod 2775
    #find "$dir/shared/dev/oosh" -type f -print0 | xargs -0 chmod +grwx


    cd "$dir/developking/"
    wget -r -np --cut-dirs=9 -R "index.html*" "https://test.wo-da.de/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/NewUserStuff/scripts/templates/developking.ssh"
    chown -R developking:dev "$dir/developking/test.wo-da.de/developking.ssh"
    mv "$dir/developking/test.wo-da.de/developking.ssh" "$dir/developking/.ssh"
    rm -rf "$dir/developking/test.wo-da.de"

    ossh config.create 2cuGitHub git@github.com:Cerulean-Circle-GmbH/once.sh.git "$dir/developking/.ssh/id_rsa"
    ossh config.save.last



    cd "$dir/shared/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/Once.sh"
    git clone 2cuGitHub:Cerulean-Circle-GmbH/once.sh.git main
    RETURN_VALUE=$?
    if ! [ "$RETURN_VALUE" = "0" ]; then return $RETURN_VALUE; fi

    git clone 2cuGitHub:Cerulean-Circle-GmbH/once.sh.git dev
    RETURN_VALUE=$?
    if ! [ "$RETURN_VALUE" = "0" ]; then return $RETURN_VALUE; fi
    cd dev
    git checkout -t origin/dev



    # ln -s "$dir/shared/dev/oosh"
    # chown -h developking:dev "oosh"


    important.log "before config copy:
    SSH_CONFIG_NAME_USED_FOR_LOCAL
    $SSH_CONFIG_NAME_USED_FOR_LOCAL"

    local paramerUser="$( echo $SSH_CONFIG_NAME_USED_FOR_LOCAL | line replace 'user.' )"
    local currentHome="$( user get home $paramerUser )"
    info.log "paramerUser=$paramerUser"
    local currentUserDir=$( echo $currentHome | line replace.sedquoted "$dir/")
    info.log "currentUserDir=$currentUserDir"

    local currentConfig="$dir/$currentUserDir/config"

    info.log "currentConfig=$currentConfig"



  set -x
    # link root config to sharedConfig
    cp -r "/root/config" "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    rm -rf "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig/stateMachines"
    cp -r "$currentConfig/stateMachines" "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    
    # link user config to sharedConfig
    mv "$currentConfig" "$currentConfig.initial"
    ln -s "$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig" "$currentConfig"
    chown -h $paramerUser:dev "$currentConfig"

    export PATH="$( echo $PATH | line replace.sedquoted "/root/oosh" "$dir/shared/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/Once.sh/dev" )"

    mv /root/config /root/config.initial
  set +x



    export CONFIG="$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig/user.env"
    export CONFIG_FILE="user.env"
    export CONFIG_PATH="$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    export OOSH_DIR="$dir/shared/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/Once.sh/dev"
    export OOSH_MODE="dev"

    important.log "PATH=$PATH"
    config save 
    
  
  set -x
    cd /root
    ln -s "$CONFIG_PATH" config
    chown -R developking:dev "$CONFIG_PATH"
    
    #mv config "config.orig"
    #ln -s "$CONFIG_PATH" config
    mv oosh oosh.http
    ln -s "$OOSH_DIR" oosh

    ls -la "$dir/shared/dev"
    tree -L 2 /home/shared
    ls -la /root


  set +x
    create.result 0 "root.shared.dev.folder.created" $1
  fi

  

  #check.debug.level 3
  return $(result)
}

oo.tmp.cleanup.testing() { # # clean test
    source user
    user.delete.linux developking
    rm -rf /home/shared
    state set 30
    oo update
}


private.check.root.dev.keys.installed() {
  return 0
}
private.check.root.installation.done() {
  return 0
}

private.check.user.shared.dev.folder.linked() {
  local devHome="$( user get home developking )"
  if [ -z "$devHome" ]; then
    error.log "user developking does not yet exist"
    return 2
  fi
  this.absolutePath "$devHome/.."
  info.log "absolutePath of \"$devHome\..\": $RESULT"
  local dir="$RESULT"

    export CONFIG="$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig/user.env"
    export CONFIG_FILE="user.env"
    export CONFIG_PATH="$dir/shared/EAMD.ucp/Scenarios/localhost/EAM/1_infrastructure/Once.sh/sharedConfig"
    export OOSH_DIR="$dir/shared/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/Once.sh/dev"
    export OOSH_MODE="dev"

    cd $HOME
    if [ -L config ]; then
      success.log "config is alredy a link"
      ls -al config
      return 0
    else
      mv config "config.orig"
      ln -s "$CONFIG_PATH" config
      ln -s "$OOSH_DIR" oosh
    fi

  return 0
}
private.check.user.state.machine.synced.with.root() {
  return 0
}

private.check.headless.setup.started() {
  return 0
}

private.check.headless.setup.finished() {
  return 0
}

private.check.once.setup.started() {
  return 0
}

private.check.once.setup.finished() {
  return 0
}

private.check.finished() {
  return 0
}


oo.install.dev() # # install the official dev oosh. GitHub keys required
{
  cd $OOSH_DIR
  cd ..

  check dir /var/dev not exists \
    call once su.mkdir.dev $USER
  
  ossh config.create 2cuGitHub git@github.com:Cerulean-Circle-GmbH/once.sh.git '~/.ssh/ids/ssh.marcel.iMac/private_key/donges.mcdonges.fritz.box.private_key'
  ossh config.save.last
  ossh pull.id iMac

  cd /var/dev/Workspaces/2cuGitHub
  check dir /var/dev/Workspaces/2cuGitHub/once.sh/.git not exists \
    call git clone 2cuGitHub:Cerulean-Circle-GmbH/once.sh.git
  check dir ~/oosh exists \
    call mv ~/oosh/ ~/oosh.https
  ln -s /var/dev/Workspaces/2cuGitHub/once.sh ~/oosh
  check dir ~/init.bak exists \
    call rm -r ~/init.bak
  check dir ~/init.bak not exists \
    call mv ~/init ~/init.bak

  
}

oo.mode.fullDebug() # # switches to fullDebug branch
{
  cd $OOSH_DIR
  git pull
  git checkout fullDebug
  git merge dev
  git push
}

oo.cmd() # <cmd> <?packageName> # checks if <cmd> is installed and installes it with: $SUDO $PM <?packageName>
{
    current=$1
    shift
    package=$1

    if [ -z "$1" ]; then
        package=$current
    else
      shift
      package=$1
    fi   
    
    if [ -z "$OOSH_PM" ]; then
      console.log "no PM found...checking" 
      oo.pm.discover
    fi
    if ! [ -x "$(command -v $current)" ]; then
        console.log "no $current"
        if [ -n "$OOSH_PM" ]; then
          case $current in
            eamd)
              once load $current tla/EAMD/UcpComponentSupport/1.0.0/src/sh/eamd
              export PATH="$PATH:$ONCE_LOAD_DIR"
              hash -d eamd    #clears the command cache for eamd
              #hash -r   #clears the command cache completley
              ;;
            oosh)
              once load $current com/ceruleanCircle/EAM/1_infrastructure/OOSH/1.0.0/src/sh/oosh
              ;;
            once)
              once load once.sh tla/EAM/layer1/Thinglish/Once/latestServer/src/sh/once.sh
              cd $ONCE_LOAD_DIR
              mv once.sh once
              private.stage status
              ;;
            npm)
              # if ! which $current > /dev/null; then
                once.su.npm.install
              # else
              #   console.log "$current allready installed!";
              # fi
              # exit;
              ;;
            mkcert)
              once.su.mkcert.install
              ;;
            update)
              if [ -z "$OOSH_PM_UPDATED" ]; then
                $SUDO apt-get update
              else
                warn.log "Package manager already updated with: $OOSH_PM_UPDATED"
              fi
              ;;
            *)
              $SUDO $OOSH_PM $package
            esac
        else
            console.log "no package manger"
        fi
        if [ -n "$1" ]; then
          shift
        fi
    fi
    RETURN=$1
}

oo.pm() # # checks if the pm is well configured
{
  if [ -n "$OOSH_PM" ]; then
    important.log "package manager is set:"
    console.log "for OOSH: $OOSH_PM"
    console.log "for ONCE: $ONCE_PM"
    if [ "$OOSH_PM" = "$ONCE_PM" ]; then
      success.log "package manager well configured"
      return 0
    else
      warn.log "package manager differ!
      use
      
        oo pm.discover
      
      to fix that
      "
      return 1
    fi
  fi
  OOSH_PM=
  private.check.all.pm
  console.log "PM: $OOSH_PM"

  RETURN=$1
}

oo.pm.discover() # # finds out OS and corresponding package manager (pm)
{
  OOSH_PM=
  private.check.all.pm
  console.log "OOSH_PM: $OOSH_PM"
  config save

  RETURN=$1
}

private.check.pm()             # checks for a package manager
{

    local packageManager=$1
    local packageManagerCommand=$2


    if [ -z "$packageManagerCommand" ]; then
        package=$packageManager
    fi   
    if ! [ -x "$(command -v $packageManager)" ]; then
        debug.log "no $packageManager"
    else
        if [ -z "$OOSH_PM" ]; then
            export OOSH_PM=$packageManagerCommand
            export OS_CMD_GROUP_ADD=$3
            export OS_CMD_USER_ADD=$4
            echo "Package Manager found: using $OOSH_PM somePackage"
            if [ "$packageManager" = "apt-get" ]; then
                if [ -z "$OOSH_PM_UPDATED" ]; then
                  OOSH_PM_UPDATED="$SUDO apt-get update"
                  #if [ "$ONCE_PRIVILEGE" = root ]; then
                    $OOSH_PM_UPDATED
                  # else 
                  #   PM="sudo $PM"
                  # fi
                else
                  echo "in case of installation errors try to call: apt-get update"
                fi
            fi
            config save os.commands "OS_CMD"
        fi
    fi
}

private.check.all.pm()         # adds tools and configurations to package manager (brew, apt-get, addgroup, adduser, dpkg, pkg)
{

    private.check.pm brew "brew install"    
    #once.check.pm apt "apt add"
    private.check.pm apt-get "apt-get -y install" "groupadd -f" "useradd -g dev"
    private.check.pm apk "apk add" "addgroup" "adduser -g dev"
    private.check.pm dpkg "dpkg install"
    private.check.pm pkg "pkg install"
    private.check.pm pacman "pacman -S"

 
}

oo.install() { # <scriptClass> <path> # installs an external oo script from <path> into oosh/external as a link
  local class="$1"
  shift
  local path="$1"
  shift

  if [ -z "$path" ]; then
    this.absolutePath .
    path=$RESULT
  fi

  this.absolutePath $path
  path=$RESULT

  debug.log "path: $path"
  if [ -L "$OOSH_DIR/external/$class" ]; then
    important.log "updating links: $OOSH_DIR/external/$class -> $path/$class"
    rm $OOSH_DIR/external/$class
    ln -s $path/$class $OOSH_DIR/external/$class
  fi

  if [ -f "$path/$class" ]; then
    important.log "installing link: $class -> $path/$class"
    rm $OOSH_DIR/external/$class
    ln -s "$path/$class" "$OOSH_DIR/external/$class"
  fi

  if [ -f "$OOSH_DIR/$class" ]; then
    important.log "installing: $class -> $path/$class"
    mv "$OOSH_DIR/$class" "$path/$class"
    ln -s "$path/$class" "$OOSH_DIR/external/$class"
  fi

}

oo.install.completion() {
  compgen -d $OOSH_DIR/$1
}

oo.find.cmd() { # <cmd> # finds the <cmd> on the apt repositories
  oo cmd apt-file
  apt-file update
  apt-file search --regexp ".*$1$"
}


oo.su() {
  if [ "$USER" = "root" ]; then
    cd $OOSH_DIR/su
    echo ${GREEN}root command are:
    ls -al
    echo ${NORMAL}
    bash
  else
    error.log "You are not root! 
        ${BOLD_YELLOW}USER: $USER"

    warn.log "trying to switch to root:
    
    Type user $USER"
    sudo su
  fi
}

oo.usage()
{
  local this=${0##*/}
  echo "You started" 
  echo "$0

  is the management interface for the oosh environment
  create new classes with: oo new <class>

  The oosh lifecycle
    1. oo mode.dev  # All development exclusively in dev mode
    2. oo update    # Updating oosh environment to the latest
    3. oo commit    # Commit local changes to the oosh dev global environment
    4. oo release   # Publish the dev environment to the main environment as well as switching to main mode. This is the commercial mode for using the oosh environment
    5. oo mode.dev  # Switch back do dev mode to start development cycle again


  ${CYAN}\$OOSH_DIR${NORMAL}           is where it is installed: $OOSH_DIR
  ${CYAN}\$OOSH_DIR/${GREEN}init/oosh${NORMAL} is the ${YELLOW}initial${NORMAL} installer based on the ${GREEN}sh${NORMAL} Shell
  ${CYAN}\$OOSH_DIR/${GREEN}this${NORMAL}      is ${YELLOW}starting${NORMAL} the oosh environment and provides common oo functionality

  Usage:
  $this: command   description and Parameter

      usage     prints this dialog while it will print the status when tehere are no parameters          
      ----      --------------------------"
  this.help
  echo "
  ${GREEN}Examples${NORMAL} 
    $this new myNewCommand
    $this update
  "
}

oo.start() # <method> <parameter> # default start and parameter processing
{
  #echo "sourcing init"
  source this

  # if [ -z "$1" ]; then
  #   status.discover "$@"
  #   return 0
  # fi

  this.start "$@"
}

oo.start "$@"

