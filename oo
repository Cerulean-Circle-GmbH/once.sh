#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"


oo.new()
{
  if [ -n "$1" ]; then
    info.log "oosh in $OOSH_DIR"
    cd $OOSH_DIR
    cat ./templates/code/new_script | sed 's/new_script/'"$1"'/' >./$1
    chmod +x ./$1
    success.log "created oo script $1"
    important.log "to enable completion on the new command, type

    reconfigure"

    cd $OOSH_DIR/test
    cat ./../templates/code/new_script_test | sed 's/new_script/'"$1"'/' > test.$1
    chmod +x ./test.$1
    success.log "created test script test.$1"

  else
    warn.log "usage: oo new filename
    
    please specify a filename"
    return 1
  fi
}

oo.new.method()   # oo new.method new_script.new_method 
{
  local name="$1"
  if [ -z "$name" ]; then
    error.log "No parameter provided."
    return 1
  fi
  local new_script=$(echo $name | cut -d. -f1)
  local new_method=$(echo $name | cut -d. -f2)
  
  if [ -z "$new_method" ]; then
    warn.log "check if the parameter contains a ."
    error.lgo "no method name in: $name:"
    return 2
  fi
  console.log "
  command: $new_script
  method : $new_method
  "

  if check file $OOSH_DIR/$new_script exists fix error.log "$OOSH_DIR/$new_script does not exist"
  then
    local tweaked_method=$(cat $OOSH_DIR/templates/code/new_method | sed 's/new_script/'"$new_script"'/' | sed 's/new_method/'"$new_method"'/')
    local replace_text="### new.method"

    replace within "$OOSH_DIR/$new_script" "$replace_text" by "$tweaked_method"


    local replace_name_desc="      ----      --------------------------"
    local new_name_desc="      ----      --------------------------
      ----      --------------------------"

    replace within "$OOSH_DIR/$new_script.new" "$replace_name_desc" by "$new_name_desc"

    sed -i '0,/----/{s/----/'"$new_method"'/}' $OOSH_DIR/$new_script.new

    local descript_parameter
    echo "A short description and Parameter(s) for method" $new_method "of" $new_script": "
    read descript_parameter
    echo "$descript_parameter"

    sed -i '0,/--------------------------/{s/--------------------------/'"$descript_parameter"'/}' $OOSH_DIR/$new_script.new

    replace commit "$OOSH_DIR/$new_script"

    replace cleanup "$OOSH_DIR/$new_script"

    success.log "created oo new method in script $1"
    
  fi

  if check file $OOSH_DIR/test/test.$new_script exists fix error.log "$OOSH_DIR/test/test.$new_script does not exist"
  then
    local tweaked_test_method=$(cat $OOSH_DIR/templates/code/new_method_test | sed 's/new_script/'"$new_script"'/' | sed 's/new_method/'"$new_method"'/')
    local replace_test_text="### test.method"

    replace within "$OOSH_DIR/test/test.$new_script" "$replace_test_text" by "$tweaked_test_method"

    local test_description
    echo "Give a short description of the test" $new_method "of script" $new_script": "
    read test_description
    echo "$test_description"

    sed -i '0,/test_description/{s/test_description/'"$test_description"'/}' $OOSH_DIR/test/test.$new_script.new

    local test_parameter
    echo "Give the parameters for test" $new_method "of script" $new_script": "
    read test_parameter
    echo "$test_parameter"

    sed -i '0,/new_argument(s)/{s/new_argument(s)/'"$test_parameter"'/}' $OOSH_DIR/test/test.$new_script.new

    local test_expect
    echo "What to expect of test" $new_method "of script" $new_script": "
    read test_expect
    echo "$test_expect"

    sed -i '0,/new_expect/{s/new_expect/'"$test_expect"'/}' $OOSH_DIR/test/test.$new_script.new
    
    replace commit "$OOSH_DIR/test/test.$new_script"

    replace cleanup "$OOSH_DIR/test/test.$new_script"

    success.log "created new test for method $1"
    
  fi

}



oo.commit()
{
  cd $OOSH_DIR
  git add *
  git commit
  git push
}

oo.update()
{
  cd $OOSH_DIR
  git pull
}

oo.cmd()
{
  once cmd "$@"
}

oo.pm()
{
  oo.cmd "$@"
}

oo.install() {
  local class="$1"
  shift
  local path="$1"
  shift

  if [ -z "$path" ]; then
    this.absolutePath .
    path=$RESULT
  fi

  this.absolutePath $path
  path=$RESULT

  debug.log "path: $path"
  if [ -L "$OOSH_DIR/external/$class" ]; then
    important.log "updating links: $OOSH_DIR/external/$class -> $path/$class"
    rm $OOSH_DIR/external/$class
    ln -s $path/$class $OOSH_DIR/external/$class
  fi

  if [ -f "$path/$class" ]; then
    important.log "installing link: $class -> $path/$class"
    rm $OOSH_DIR/external/$class
    ln -s "$path/$class" "$OOSH_DIR/external/$class"
  fi

  if [ -f "$OOSH_DIR/$class" ]; then
    important.log "installing: $class -> $path/$class"
    mv "$OOSH_DIR/$class" "$path/$class"
    ln -s "$path/$class" "$OOSH_DIR/external/$class"
  fi

}

oo.find.cmd() {
  apt-file search --regexp ".*$1$"
}


oo.install.completion() {
  compgen -d $OOSH_DIR/$1
}


oo.usage()
{
  local this=${0##*/}
  echo "You started 
$0

  Usage:
  $this: command   description and Parameter

      usage     prints this dialog while it will print the status when tehere are no parameters          
      v         print version information
      init      initializes ...nothing yet

      new         <name> creates a new oosh class script and test
      new.method  <name> add a new method to the oosh class script and test
      install     <name> <path:"."> installs the oosh class in path and makes a lin into oosh/external

  Examples
    $this v
    $this init
  "
}

oo.start()
{
  #echo "sourcing init"
  source this

  # if [ -z "$1" ]; then
  #   status.discover "$@"
  #   return 0
  # fi

  this.start "$@"
}

oo.start "$@"

