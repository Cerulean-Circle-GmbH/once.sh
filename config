#!/bin/bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"

config.v() {
  echo "$0 version 2021-10-19 15:25"
}

config.ci() {
  config.completion.install
  #$OOSH_PATH/oosh 
}

config.completion.install() 
{
  DIR=${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions
  config.path.create $DIR
  echo -e "
_oo_commands()
{
    #echo processing once completion
    local cur prev opts
    local IFS=$'\\\\n'

    COMPREPLY=()
    cur=\"\${COMP_WORDS[COMP_CWORD]}\"
    prev=\"\${COMP_WORDS[COMP_CWORD-1]}\"
    
    #echo \"curr: \${cur}  COMP_CWORD: \$COMP_CWORD  WORDs: =\${COMP_WORDS[*]}= \"
    opts=\$(once completion.discover \"\${COMP_WORDS[*]}\")
 
    COMPREPLY=( \"\${opts}\" )
    return 0
}
  
#complete -F _oo_commands once

for file in \${OOSH_PATH}/*; do
    name=\${file##*/}
    if [[ -x \"\$file\" ]]; then
      echo \"added completion for: \$name\"
      complete -F _oo_commands \$name
    fi
done
  " >$DIR/_oosh_commands
  if [ ! -f ~/.bashrc.bak.without.completion ]; then
    cp ~/.bashrc ~/.bashrc.bak.without.completion 
  fi
  cp /var/dev/EAMD.ucp/Components/com/ceruleanCircle/EAM/1_infrastructure/NewUserStuff/scripts/templates/.bashrc ~/.bashrc
} 


config.list.completion() {
  echo "file"
  for file in ${CONFIG_PATH}/*.env 
    do
      echo $file | cut -d. -f1
    done
}

config.init()
{
  CONFIG_PATH=~/config
  CONFIG_FILE=user.env

  if [ ! -d ~/config ]; then
    mkdir ~/config
  #else
  #  source $CONFIG
  fi
  
  export CONFIG=$CONFIG_PATH/$CONFIG_FILE
  debug.log "$CONFIG"
}

config.usage()
{
  local this=${0##*/}
  echo "You started 
$0

  current file: $CONFIG
   CONFIG_PATH=$CONFIG_PATH
   CONFIG_FILE=$CONFIG_FILE


  Usage:
  $this: command   description and Parameter
      v         print version information
      init      initializes a new user config
      save      <?name> saves all vaiables containing NAME to name.env
      list      <?name> lists all vaiables in name.env
      add       <?name> lists all vaiables containing NAME to $CONFIG
      delete    <?name> deletes name.env
  
  Examples
    update current shell
      . \$CONFIG
      . $CONFIG

    $this v
    $this save once
    $this list oosh
  "
  
  #loop.list PATH print '---------------------: '
}

config.save() 
{

  local file=$1
  shift
  local name=${file^^}

  if [ -n "$file" ]; then
    config.file $file.env
  else
    name="CONFIG"
  fi
  
  console.log "
  config.save $* to $CONFIG"
    #declare -px | grep "^\(declare .* \)*\(.*$name\)\(.*\)=" | sed 's/^\(declare .* \)*\(.*'$name'\)\(.*\)=\(\"\)*\([^\"]*\)\(\"\)*/export \2\3=\"\5\"/'
    #declare -p | grep "^\(declare -.* \)*\(.*$name\)\(.*\)=" | sed 's/^\(declare -.* \)*\(.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
  RESULT=""
  {    
    #declare -p | grep "^\(declare -[^a]* \)*\([^ ]*$name\)\(.*\)=" | sed 's/^\(declare -.* \)*\((.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
    declare -p | grep "^\(declare -[^aA]* \)*\([^ ]*$name\)\(.*\)=" | sed 's/^\(declare -.* \)\(.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
  } >$CONFIG

  if [ -z "$file" ]; then
    echo "export PATH=$PATH" >>$CONFIG
    echo "export CONFIG" >>$CONFIG
    config.save oosh
    config.save log
    config.file user.env
    config.add oosh
    config.add log
  fi
  config.info.log
}

config.list()
{
  config.check.file $1
  cat $CONFIG
}

config.delete()
{
  config.check.file $1
  rm $CONFIG_PATH/$CONFIG_FILE
}

config.update()
{
  config.save $1
  config.add $1
  config.info.log
}

config.info.log()
{
  if [ "$LOG_LEVEL" -gt "3" ]; then
    config.list $1
  fi
}

config.edit()
{
  if (config.check.file $1); then
    vim $CONFIG
  else
    vim $CONFIG
    exit $ERROR_CODE_RECONFIG
  fi
}

config.clean()
{
  config.check.file $1
  sort -u $CONFIG >$CONFIG_PATH/$CONFIG_FILE.clean
  rm $CONFIG_PATH/$CONFIG_FILE
  mv $CONFIG_PATH/$CONFIG_FILE.clean $CONFIG_PATH/$CONFIG_FILE
  if [ "$LOG_LEVEL" -gt "3" ]; then
    config.list $1
  fi
}

config.add()
{
  local file=$1
  shift
  local name=${file^^}

  if [ -z "$file" ]; then
    name="CONFIG"
  fi
  
  console.log "
  config.add $* to $CONFIG"
  {
    echo source \$CONFIG_PATH/$file.env
  } >>$CONFIG
  config.clean
}

config.check.file() 
{
  if [ -n "$1" ]; then
    config.file $1.env
    shift
    RETURN=$1
    RETURN_VALUE=0
  else 
    RETURN_VALUE=1
  fi
  info.log "config file: $CONFIG"
  return $RETURN_VALUE

}

config.file()
{
  if [ -z "$1" ]; then
    echo "$CONFIG_FILE"
  else
    case "$1" in
      reset)
        config.init
        echo "CONFIG_PATH=$CONFIG_PATH"
        echo "CONFIG_FILE=$CONFIG_FILE"
        echo
        echo "CONFIG=$CONFIG"
        ;;
      *)
        export FILE=$1
        CONFIG_FILE=$FILE

        export CONFIG=$CONFIG_PATH/$CONFIG_FILE
    esac
  fi
}

function config.path.create()          # creates respective paths
{
    debug.log " function ${FUNCNAME[0]}($1) $@"

    if [[ "$1" = /* ]]; then
        cd "/"
    fi

    path=""
    info.log "creating path in $(pwd): $1"

    for current in ${1//// }; do

        if [ -z "$path" ]; then
            path=$current
        else
            path=$path/$current
        fi
        debug.log "checking path: $path"

        config.folder.create $path
    done
}

function config.folder.create()            # creates respective directory requested in parameter 
{

    local current=$1
    if [ ! -d $current ]; then
        debug.log "$current does not exist: creating it..."
        mkdir -p $current
    fi
}

config.discover()
{
  ls $CONFIG_PATH
}

function config.start()
{
  #echo "sourcing init"
  source init
  if ! [ -f "$CONFIG" ]; then
      config.init
      "$@"
      return 0
  fi
  if [ -z "$CONFIG_PATH" ]; then
      config.init
  fi

  if [ "$(type -t this.start)" = "function" ]; then
    this.start "$@"
  else
    echo "config.start: this.start not yet there"
  fi
}

config.start "$@"

