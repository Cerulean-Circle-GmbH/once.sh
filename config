#!/usr/bin/env bash
#clear
#export PS4='\033[90m+${LINENO} in ${#BASH_SOURCE[@]}>${FUNCNAME[0]}:${BASH_SOURCE[@]##*/} \033[0m'
#set -x

#echo "starting: $0 <LOG_LEVEL=$1>"


config.v() {
  echo "$0 version 2021-10-29 13:15"
}


config.completion.discover() {
  #set -x
  #info.log "completion.discover $*"
  local command=$1
  shift
  local ac=$(which $command)
  case "${command}" in
    "init"|"oosh"|"this")
      command="this"
      ac=$OOSH_DIR/this
    ;;
    "oo")
      if [ -n "$1" ]; then
        command=$1
        ac=$(which $command)
        shift
      fi
      complete -F _oo_commands $command
    ;;    
    "once.sh")
      command="once"
    ;;
    "config")
      debug.log "in config"
      ac=$OOSH_DIR/config
    ;;
    *)
      debug.log "$command not found in completion"
    ;;
  esac
  
  local method=""
  local previous=""
  local last=""
  while [ -n "$1" ]; do
   previous=$method
   if [ -z "$method" ]; then
    method=$1
   else
    method=$method.$1
   fi
   last=$1
   shift
  done

  # if [ -n "$command" ]; then
  #   if [ -x "$(command -v $command)" ]; then
  #     info.log "sourcing $command"
  #     #source "$command"
  #   else
  #     return 1
  #   fi
  # else
  #   return 1
  # fi


  if (config.check.completion $command $previous); then
      $ac $previous.completion $last $command $previous
  fi

  if (config.check.completion $command $last); then
    if [ "$ac" = "$OOSH_DIR/config" ]; then
      if (this.functionExists $command.$last.completion); then
        $command.$last.completion '' $command $previous
        return 0
      fi
      if (this.functionExists $command.$previous.completion); then
        $command.$previous.completion $last $command $previous
        return 0
      fi
    else

      $ac $last.completion '' $command $previous
      return 0
    fi
  fi
  # if (this.functionExists $command.$previous.completion); then
  #   $command.$previous.completion $last $command $previous
  #   return 0
  # fi

  if [[ $method == *[\\/\(\)]* ]]; then
    create.result 1 "$method contains special charaters"
    #echo $RESULT
    return "$(result)" 
  fi

  #echo method:$method
  local find="^\(function \)*\($command\.\)\($method[^(#\"]*\)\(.*\)"

  grep "$find" $ac | sed 's/'"$find"'/\3/' | sed 's/\(.*\)\(\.completion.*\)/\1/'
  #echo "$@"
}

config.check.completion() {
  local command=$1
  local ac=$(which $command)
  local method="$2.completion"
  local find="^\(function \)*\($command\.\)\($method[^(#\"]*\)\(.*\)"
  if [[ $method == *[\\/\(\)]* ]]; then
    create.result 1 "$method contains special charaters"
    #echo $RESULT
    return "$(result)" 
  fi
  RESULT=$(grep "$find" $ac | sed 's/'"$find"'/\3/')
  if [ "$RESULT" = "$method" ]; then
    create.result 0 "$RESULT"
  else
    create.result 1 "$method not found" 
  fi 
  debug.log "$RESULT"
  return "$(result)"
}

config.local()
{
  check dir ~/oosh exists call mv ~/oosh/ ~/oosh.gh
  ln -s /var/dev/Workspaces/2cuGitHub/once.sh oosh
  check dir ~/init.bak exists call rm -r ~/init.bak
  check dir ~/init.bak not exists call mv ~/init ~/init.bak
  #check dir ~/init not exists cp -r ~/oosh/init ~/init
  check dir ~/init not exists ln -s ~/oosh/init ~/init

}

config.ci() {
  config.completion.install
  #$OOSH_DIR/oosh 
}

config.completion.install() 
{
  DIR=${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions
  config.path.create $DIR
  echo -e "
_oo_commands()
{
    #set -x
    #echo processing once completion
    local cur prev opts
    local IFS=$'\\\\n'

    COMPREPLY=()
    cur=\"\${COMP_WORDS[COMP_CWORD]}\"
    prev=\"\${COMP_WORDS[COMP_CWORD-1]}\"
    
    #echo \"curr: \${cur}  COMP_CWORD: \$COMP_CWORD  WORDs: =\${COMP_WORDS[*]}= \"
    opts=\$(config completion.discover \${COMP_WORDS[*]})
 
    if [ \$COMP_CWORD -gt 1 ] && [ \"$opts\" = \"\${COMP_WORDS[-1]}\"  ]; then
      COMPREPLY=( \$(compgen -o default \$cur) )
      return 0
    fi
    
    COMPREPLY=( \${opts} )
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=( \$(compgen -o default -o plusdirs \$cur) )
    fi

    return 0
}
  
add_to_completion() {
  path=\"\$1\"

  for file in \${path}/*; do
      name=\${file##*/}
      if [[ -f \"\$file\" ]]; then
        #info.log \"added completion for: \$name\"
        complete -F _oo_commands \$name -o bashdefault -o default
      fi
  done

  echo added completions for commands in \${path}
}

complete -F _oo_commands once
add_to_completion \${OOSH_DIR}
add_to_completion \${OOSH_DIR}/external


  " >$DIR/_oosh_commands
  if [ ! -f ~/.bashrc.bak.without.completion ]; then
    cp ~/.bashrc ~/.bashrc.bak.without.completion 
  fi
  cp $OOSH_DIR/templates/user/bashrc_template ~/.bashrc
} 


config.edit.completion() {
  config.list.completion "$@"
}

config.delete.completion() {
  config.list.completion "$@"
}



config.list.completion() {
  #echo "$@"
  export FILTER=$1
  for file in ${CONFIG_PATH}/*.env 
    do
      echo "$(basename $file)" | cut -d. -f1 | grep "^$FILTER"
    done
}

config.string.quote () { 
  RESULT=$(printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/")
  echo $RESULT
}

config.init()
{
  CONFIG_PATH=~/config
  CONFIG_FILE=user.env

  if [ ! -d ~/config ]; then
    mkdir ~/config
  #else
  #  source $CONFIG
  fi
  
  export CONFIG=$CONFIG_PATH/$CONFIG_FILE
  debug.log "$CONFIG"
}

config.usage()
{
  local this=${0##*/}
  echo "You started 
$0

  current file: $CONFIG
   CONFIG_PATH=$CONFIG_PATH
   CONFIG_FILE=$CONFIG_FILE


  Usage:
  $this: command   description and Parameter
      v         print version information
      init      initializes a new user config
      save      <?name> <?ENV_NAME> saves all vaiables containing ENV_NAME to name.env
      list      <?name> lists all vaiables in name.env
      add       <?name> lists all vaiables containing NAME to $CONFIG
      delete    <?name> deletes name.env
  
  Examples
    update current shell
      . \$CONFIG
      . $CONFIG

    $this v
    $this save once
    $this list oosh
  "
  
  #loop.list PATH print '---------------------: '
}

config.save() 
{

  local file=$1
  shift
  local name=$1
  if [ -z "$name" ]; then
    name=${file^^}
  else
    shift
  fi


  if [ -n "$file" ]; then
    config.file $file.env
  else
    name="CONFIG"
  fi
  
  console.log "
  config.save $* to $CONFIG"
    #declare -px | grep "^\(declare .* \)*\(.*$name\)\(.*\)=" | sed 's/^\(declare .* \)*\(.*'$name'\)\(.*\)=\(\"\)*\([^\"]*\)\(\"\)*/export \2\3=\"\5\"/'
    #declare -p | grep "^\(declare -.* \)*\(.*$name\)\(.*\)=" | sed 's/^\(declare -.* \)*\(.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
  RESULT=""
  {    
    #declare -p | grep "^\(declare -[^a]* \)*\([^ ]*$name\)\(.*\)=" | sed 's/^\(declare -.* \)*\((.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
    declare -p | grep "^\(declare -[^aA]* \)*\([^ ]*$name\)\(.*\)=" | sed 's/^\(declare -.* \)\(.*'$name'\)\(.*\)=\(.*\)/export \2\3=\4/'
  } >$CONFIG

  if [ -z "$file" ]; then
    echo "export PATH=$PATH" >>$CONFIG
    echo "export CONFIG" >>$CONFIG
    echo "export BASH_FILE=\"$BASH_FILE\"" >>$CONFIG
    config.save oosh OOSH
    config.save log LOG
    config.file user.env
    config.add oosh
    config.add log
    # if [ -x "$(command -v once)" ]; then
    #   once v
    # fi
  fi
  config.info.log
}

config.list()
{
  config.check.file $1
  cat $CONFIG
}

config.delete()
{
  config.check.file $1
  rm $CONFIG_PATH/$CONFIG_FILE
}

config.update()
{
  config.save $1 $2
  config.add $1
  config.info.log
}

config.info.log()
{
  if [ "$LOG_LEVEL" -gt "3" ]; then
    config.list $1
  fi
}

config.edit()
{
  #check.debug.level 6
  if config.check.file $1; then
    vim $CONFIG
  else
    vim $CONFIG
    exit $ERROR_CODE_RECONFIG
  fi
}

config.clean()
{
  config.check.file $1
  sort -u $CONFIG >$CONFIG_PATH/$CONFIG_FILE.clean
  rm $CONFIG_PATH/$CONFIG_FILE
  mv $CONFIG_PATH/$CONFIG_FILE.clean $CONFIG_PATH/$CONFIG_FILE
  if [ "$LOG_LEVEL" -gt "3" ]; then
    config.list $1
  fi
}

config.add()
{
  local file=$1
  shift
  local name=$1
  if [ -z "$name" ]; then
    name=${file^^}
  else
    shift
  fi

  if [ -z "$file" ]; then
    name="CONFIG"
  fi
  
  console.log "
  config.add $* to $CONFIG"
  {
    echo source \$CONFIG_PATH/$file.env
  } >>$CONFIG
  config.clean
}

config.check.file() 
{
  if [ -n "$1" ]; then
    config.file $1.env
    shift
    RETURN=$1
    RETURN_VALUE=0
  else 
    RETURN_VALUE=1
  fi
  info.log "config file: $CONFIG"
  create.result $RETURN_VALUE $CONFIG
  return "$(result)"

}

config.file()
{
  if [ -z "$1" ]; then
    echo "$CONFIG_FILE"
  else
    case "$1" in
      reset)
        config.init
        echo "CONFIG_PATH=$CONFIG_PATH"
        echo "CONFIG_FILE=$CONFIG_FILE"
        echo
        echo "CONFIG=$CONFIG"
        ;;
      *)
        export FILE=$1
        CONFIG_FILE=$FILE

        export CONFIG=$CONFIG_PATH/$CONFIG_FILE
    esac
  fi
}

function config.path.create()          # creates respective paths
{
    debug.log " function ${FUNCNAME[0]}($1) $@"

    if [[ "$1" = /* ]]; then
        cd "/"
    fi

    path=""
    info.log "creating path in $(pwd): $1"

    for current in ${1//// }; do

        if [ -z "$path" ]; then
            path=$current
        else
            path=$path/$current
        fi
        debug.log "checking path: $path"

        config.folder.create $path
    done
}

function config.folder.create()            # creates respective directory requested in parameter 
{

    local current=$1
    if [ ! -d $current ]; then
        debug.log "$current does not exist: creating it..."
        mkdir -p $current
    fi
}

config.ssh.set.config.host()
{ 
  export OOSH_SSH_CONFIG_HOST=$1
  config.save
  echo "To apply changes immediatly type:
  
  exit $ERROR_CODE_RECONFIG"
  exit $ERROR_CODE_RECONFIG
  #reconfigure
}


config.discover()
{
  echo $CONFIG_PATH
  ls $CONFIG_PATH
}


function config.start()
{
  #echo "sourcing init"
  COMMANDS="$@"
  source this
  #check.debug.level 6

  if ! [ -f "$CONFIG" ]; then
      config.init
      # local command=$1
      # shift
      #${1#"config."}"$@"
      this.start "$@"
      return 0
  fi
  if [ -z "$CONFIG_PATH" ]; then
      config.init
  fi
  if [ "$(type -t this.start)" = "function" ]; then
    this.start "$@"
  else
    echo "config.start: this.start not yet there"
  fi
}

config.start "$@"

